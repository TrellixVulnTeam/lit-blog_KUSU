{
  "version": 3,
  "sources": ["../../.yarn/cache/lit-html-npm-2.0.0-rc.3-bb75de0211-828168d0b2.zip/node_modules/lit-html/development/lit-html.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nvar _a, _b, _c, _d, _e;\nvar _f;\nconst DEV_MODE = true;\nconst ENABLE_EXTRA_SECURITY_HOOKS = true;\nconst ENABLE_SHADYDOM_NOPATCH = true;\nif (DEV_MODE) {\n    console.warn('lit-html is in dev mode. Not recommended for production!');\n}\nconst wrap = ENABLE_SHADYDOM_NOPATCH && ((_a = window.ShadyDOM) === null || _a === void 0 ? void 0 : _a.inUse) &&\n    ((_b = window.ShadyDOM) === null || _b === void 0 ? void 0 : _b.noPatch) === true\n    ? window.ShadyDOM.wrap\n    : (node) => node;\nconst trustedTypes = globalThis.trustedTypes;\n/**\n * Our TrustedTypePolicy for HTML which is declared using the html template\n * tag function.\n *\n * That HTML is a developer-authored constant, and is parsed with innerHTML\n * before any untrusted expressions have been mixed in. Therefor it is\n * considered safe by construction.\n */\nconst policy = trustedTypes\n    ? trustedTypes.createPolicy('lit-html', {\n        createHTML: (s) => s,\n    })\n    : undefined;\nconst identityFunction = (value) => value;\nconst noopSanitizer = (_node, _name, _type) => identityFunction;\n/** Sets the global sanitizer factory. */\nconst setSanitizer = (newSanitizer) => {\n    if (!ENABLE_EXTRA_SECURITY_HOOKS) {\n        return;\n    }\n    if (sanitizerFactoryInternal !== noopSanitizer) {\n        throw new Error(`Attempted to overwrite existing lit-html security policy.` +\n            ` setSanitizeDOMValueFactory should be called at most once.`);\n    }\n    sanitizerFactoryInternal = newSanitizer;\n};\n/**\n * Only used in internal tests, not a part of the public API.\n */\nconst _testOnlyClearSanitizerFactoryDoNotCallOrElse = () => {\n    sanitizerFactoryInternal = noopSanitizer;\n};\nconst createSanitizer = (node, name, type) => {\n    return sanitizerFactoryInternal(node, name, type);\n};\n// Added to an attribute name to mark the attribute as bound so we can find\n// it easily.\nconst boundAttributeSuffix = '$lit$';\n// This marker is used in many syntactic positions in HTML, so it must be\n// a valid element name and attribute name. We don't support dynamic names (yet)\n// but this at least ensures that the parse tree is closer to the template\n// intention.\nconst marker = `lit$${String(Math.random()).slice(9)}$`;\n// String used to tell if a comment is a marker comment\nconst markerMatch = '?' + marker;\n// Text used to insert a comment marker node. We use processing instruction\n// syntax because it's slightly smaller, but parses as a comment node.\nconst nodeMarker = `<${markerMatch}>`;\nconst d = document;\n// Creates a dynamic marker. We never have to search for these in the DOM.\nconst createMarker = (v = '') => d.createComment(v);\nconst isPrimitive = (value) => value === null || (typeof value != 'object' && typeof value != 'function');\nconst isArray = Array.isArray;\nconst isIterable = (value) => {\n    var _a;\n    return isArray(value) ||\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        typeof ((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.iterator]) === 'function';\n};\nconst SPACE_CHAR = `[ \\t\\n\\f\\r]`;\nconst ATTR_VALUE_CHAR = `[^ \\t\\n\\f\\r\"'\\`<>=]`;\nconst NAME_CHAR = `[^\\\\s\"'>=/]`;\n// These regexes represent the five parsing states that we care about in the\n// Template's HTML scanner. They match the *end* of the state they're named\n// after.\n// Depending on the match, we transition to a new state. If there's no match,\n// we stay in the same state.\n// Note that the regexes are stateful. We utilize lastIndex and sync it\n// across the multiple regexes used. In addition to the five regexes below\n// we also dynamically create a regex to find the matching end tags for raw\n// text elements.\n/**\n * End of text is: `<` followed by:\n *   (comment start) or (tag) or (dynamic tag binding)\n */\nconst textEndRegex = /<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g;\nconst COMMENT_START = 1;\nconst TAG_NAME = 2;\nconst DYNAMIC_TAG_NAME = 3;\nconst commentEndRegex = /-->/g;\n/**\n * Comments not started with <!--, like </{, can be ended by a single `>`\n */\nconst comment2EndRegex = />/g;\n/**\n * The tagEnd regex matches the end of the \"inside an opening\" tag syntax\n * position. It either matches a `>`, an attribute-like sequence, or the end\n * of the string after a space (attribute-name position ending).\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\n *\n * \" \\t\\n\\f\\r\" are HTML space characters:\n * https://infra.spec.whatwg.org/#ascii-whitespace\n *\n * So an attribute is:\n *  * The name: any character except a whitespace character, (\"), ('), \">\",\n *    \"=\", or \"/\". Note: this is different from the HTML spec which also excludes control characters.\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nconst tagEndRegex = new RegExp(`>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|(\"|')|))|$)`, 'g');\nconst ENTIRE_MATCH = 0;\nconst ATTRIBUTE_NAME = 1;\nconst SPACES_AND_EQUALS = 2;\nconst QUOTE_CHAR = 3;\nconst singleQuoteAttrEndRegex = /'/g;\nconst doubleQuoteAttrEndRegex = /\"/g;\n/**\n * Matches the raw text elements.\n *\n * Comments are not parsed within raw text elements, so we need to search their\n * text content for marker strings.\n */\nconst rawTextElement = /^(?:script|style|textarea)$/i;\n/** TemplateResult types */\nconst HTML_RESULT = 1;\nconst SVG_RESULT = 2;\n// TemplatePart types\n// IMPORTANT: these must match the values in PartType\nconst ATTRIBUTE_PART = 1;\nconst CHILD_PART = 2;\nconst PROPERTY_PART = 3;\nconst BOOLEAN_ATTRIBUTE_PART = 4;\nconst EVENT_PART = 5;\nconst ELEMENT_PART = 6;\nconst COMMENT_PART = 7;\n/**\n * Generates a template literal tag function that returns a TemplateResult with\n * the given result type.\n */\nconst tag = (_$litType$) => (strings, ...values) => ({\n    _$litType$,\n    strings,\n    values,\n});\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = tag(HTML_RESULT);\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = tag(SVG_RESULT);\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nexport const noChange = Symbol.for('lit-noChange');\n/**\n * A sentinel value that signals a ChildPart to fully clear its content.\n */\nexport const nothing = Symbol.for('lit-nothing');\n/**\n * The cache of prepared templates, keyed by the tagged TemplateStringsArray\n * and _not_ accounting for the specific template tag used. This means that\n * template tags cannot be dynamic - the must statically be one of html, svg,\n * or attr. This restriction simplifies the cache lookup, which is on the hot\n * path for rendering.\n */\nconst templateCache = new WeakMap();\n/**\n * Renders a value, usually a lit-html TemplateResult, to the container.\n * @param value\n * @param container\n * @param options\n */\nexport const render = (value, container, options) => {\n    var _a, _b;\n    const partOwnerNode = (_a = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _a !== void 0 ? _a : container;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let part = partOwnerNode._$litPart$;\n    if (part === undefined) {\n        const endNode = (_b = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _b !== void 0 ? _b : null;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        partOwnerNode._$litPart$ = part = new ChildPart(container.insertBefore(createMarker(), endNode), endNode, undefined, options);\n    }\n    part._$setValue(value);\n    return part;\n};\nif (ENABLE_EXTRA_SECURITY_HOOKS) {\n    render.setSanitizer = setSanitizer;\n    render.createSanitizer = createSanitizer;\n    if (DEV_MODE) {\n        render._testOnlyClearSanitizerFactoryDoNotCallOrElse = _testOnlyClearSanitizerFactoryDoNotCallOrElse;\n    }\n}\nconst walker = d.createTreeWalker(d, 129 /* NodeFilter.SHOW_{ELEMENT|COMMENT} */, null, false);\nlet sanitizerFactoryInternal = noopSanitizer;\n/**\n * Returns an HTML string for the given TemplateStringsArray and result type\n * (HTML or SVG), along with the case-sensitive bound attribute names in\n * template order. The HTML contains comment comment markers denoting the\n * `ChildPart`s and suffixes on bound attributes denoting the `AttributeParts`.\n *\n * @param strings template strings array\n * @param type HTML or SVG\n * @return Array containing `[html, attrNames]` (array returned for terseness,\n *     to avoid object fields since this code is shared with non-minified SSR\n *     code)\n */\nconst getTemplateHtml = (strings, type) => {\n    // Insert makers into the template HTML to represent the position of\n    // bindings. The following code scans the template strings to determine the\n    // syntactic position of the bindings. They can be in text position, where\n    // we insert an HTML comment, attribute value position, where we insert a\n    // sentinel string and re-write the attribute name, or inside a tag where\n    // we insert the sentinel string.\n    const l = strings.length - 1;\n    // Stores the case-sensitive bound attribute names in the order of their\n    // parts. ElementParts are also reflected in this array as undefined\n    // rather than a string, to disambiguate from attribute bindings.\n    const attrNames = [];\n    let html = type === SVG_RESULT ? '<svg>' : '';\n    // When we're inside a raw text tag (not it's text content), the regex\n    // will still be tagRegex so we can find attributes, but will switch to\n    // this regex when the tag ends.\n    let rawTextEndRegex;\n    // The current parsing state, represented as a reference to one of the\n    // regexes\n    let regex = textEndRegex;\n    for (let i = 0; i < l; i++) {\n        const s = strings[i];\n        // The index of the end of the last attribute name. When this is\n        // positive at end of a string, it means we're in an attribute value\n        // position and need to rewrite the attribute name.\n        // We also use a special value of -2 to indicate that we encountered\n        // the end of a string in attribute name position.\n        let attrNameEndIndex = -1;\n        let attrName;\n        let lastIndex = 0;\n        let match;\n        // The conditions in this loop handle the current parse state, and the\n        // assignments to the `regex` variable are the state transitions.\n        while (lastIndex < s.length) {\n            // Make sure we start searching from where we previously left off\n            regex.lastIndex = lastIndex;\n            match = regex.exec(s);\n            if (match === null) {\n                break;\n            }\n            lastIndex = regex.lastIndex;\n            if (regex === textEndRegex) {\n                if (match[COMMENT_START] === '!--') {\n                    regex = commentEndRegex;\n                }\n                else if (match[COMMENT_START] !== undefined) {\n                    // We started a weird comment, like </{\n                    regex = comment2EndRegex;\n                }\n                else if (match[TAG_NAME] !== undefined) {\n                    if (rawTextElement.test(match[TAG_NAME])) {\n                        // Record if we encounter a raw-text element. We'll switch to\n                        // this regex at the end of the tag.\n                        rawTextEndRegex = new RegExp(`</${match[TAG_NAME]}`, 'g');\n                    }\n                    regex = tagEndRegex;\n                }\n                else if (match[DYNAMIC_TAG_NAME] !== undefined) {\n                    // dynamic tag name\n                    regex = tagEndRegex;\n                }\n            }\n            else if (regex === tagEndRegex) {\n                if (match[ENTIRE_MATCH] === '>') {\n                    // End of a tag. If we had started a raw-text element, use that\n                    // regex\n                    regex = rawTextEndRegex !== null && rawTextEndRegex !== void 0 ? rawTextEndRegex : textEndRegex;\n                    // We may be ending an unquoted attribute value, so make sure we\n                    // clear any pending attrNameEndIndex\n                    attrNameEndIndex = -1;\n                }\n                else if (match[ATTRIBUTE_NAME] === undefined) {\n                    // Attribute name position\n                    attrNameEndIndex = -2;\n                }\n                else {\n                    attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS].length;\n                    attrName = match[ATTRIBUTE_NAME];\n                    regex =\n                        match[QUOTE_CHAR] === undefined\n                            ? tagEndRegex\n                            : match[QUOTE_CHAR] === '\"'\n                                ? doubleQuoteAttrEndRegex\n                                : singleQuoteAttrEndRegex;\n                }\n            }\n            else if (regex === doubleQuoteAttrEndRegex ||\n                regex === singleQuoteAttrEndRegex) {\n                regex = tagEndRegex;\n            }\n            else if (regex === commentEndRegex || regex === comment2EndRegex) {\n                regex = textEndRegex;\n            }\n            else {\n                // Not one of the five state regexes, so it must be the dynamically\n                // created raw text regex and we're at the close of that element.\n                regex = tagEndRegex;\n                rawTextEndRegex = undefined;\n            }\n        }\n        if (DEV_MODE) {\n            // If we have a attrNameEndIndex, which indicates that we should\n            // rewrite the attribute name, assert that we're in a valid attribute\n            // position - either in a tag, or a quoted attribute value.\n            console.assert(attrNameEndIndex === -1 ||\n                regex === tagEndRegex ||\n                regex === singleQuoteAttrEndRegex ||\n                regex === doubleQuoteAttrEndRegex, 'unexpected parse state B');\n        }\n        // We have four cases:\n        //  1. We're in text position, and not in a raw text element\n        //     (regex === textEndRegex): insert a comment marker.\n        //  2. We have a non-negative attrNameEndIndex which means we need to\n        //     rewrite the attribute name to add a bound attribute suffix.\n        //  3. We're at the non-first binding in a multi-binding attribute, use a\n        //     plain marker.\n        //  4. We're somewhere else inside the tag. If we're in attribute name\n        //     position (attrNameEndIndex === -2), add a sequential suffix to\n        //     generate a unique attribute name.\n        // Detect a binding next to self-closing tag end and insert a space to\n        // separate the marker from the tag end:\n        const end = regex === tagEndRegex && strings[i + 1].startsWith('/>') ? ' ' : '';\n        html +=\n            regex === textEndRegex\n                ? s + nodeMarker\n                : attrNameEndIndex >= 0\n                    ? (attrNames.push(attrName),\n                        s.slice(0, attrNameEndIndex) +\n                            boundAttributeSuffix +\n                            s.slice(attrNameEndIndex)) +\n                        marker +\n                        end\n                    : s +\n                        marker +\n                        (attrNameEndIndex === -2 ? (attrNames.push(undefined), i) : end);\n    }\n    const htmlResult = html + (strings[l] || '<?>') + (type === SVG_RESULT ? '</svg>' : '');\n    // Returned as an array for terseness\n    return [\n        policy !== undefined\n            ? policy.createHTML(htmlResult)\n            : htmlResult,\n        attrNames,\n    ];\n};\nclass Template {\n    constructor({ strings, _$litType$: type }, options) {\n        /** @internal */\n        this.parts = [];\n        let node;\n        let nodeIndex = 0;\n        let attrNameIndex = 0;\n        const partCount = strings.length - 1;\n        const parts = this.parts;\n        // Create template element\n        const [html, attrNames] = getTemplateHtml(strings, type);\n        this.el = Template.createElement(html, options);\n        walker.currentNode = this.el.content;\n        // Reparent SVG nodes into template root\n        if (type === SVG_RESULT) {\n            const content = this.el.content;\n            const svgElement = content.firstChild;\n            svgElement.remove();\n            content.append(...svgElement.childNodes);\n        }\n        // Walk the template to find binding markers and create TemplateParts\n        while ((node = walker.nextNode()) !== null && parts.length < partCount) {\n            if (node.nodeType === 1) {\n                // TODO (justinfagnani): for attempted dynamic tag names, we don't\n                // increment the bindingIndex, and it'll be off by 1 in the element\n                // and off by two after it.\n                if (node.hasAttributes()) {\n                    // We defer removing bound attributes because on IE we might not be\n                    // iterating attributes in their template order, and would sometimes\n                    // remove an attribute that we still need to create a part for.\n                    const attrsToRemove = [];\n                    for (const name of node.getAttributeNames()) {\n                        // `name` is the name of the attribute we're iterating over, but not\n                        // _neccessarily_ the name of the attribute we will create a part\n                        // for. They can be different in browsers that don't iterate on\n                        // attributes in source order. In that case the attrNames array\n                        // contains the attribute name we'll process next. We only need the\n                        // attribute name here to know if we should process a bound attribute\n                        // on this element.\n                        if (name.endsWith(boundAttributeSuffix) ||\n                            name.startsWith(marker)) {\n                            const realName = attrNames[attrNameIndex++];\n                            attrsToRemove.push(name);\n                            if (realName !== undefined) {\n                                // Lowercase for case-sensitive SVG attributes like viewBox\n                                const value = node.getAttribute(realName.toLowerCase() + boundAttributeSuffix);\n                                const statics = value.split(marker);\n                                const m = /([.?@])?(.*)/.exec(realName);\n                                parts.push({\n                                    type: ATTRIBUTE_PART,\n                                    index: nodeIndex,\n                                    name: m[2],\n                                    strings: statics,\n                                    ctor: m[1] === '.'\n                                        ? PropertyPart\n                                        : m[1] === '?'\n                                            ? BooleanAttributePart\n                                            : m[1] === '@'\n                                                ? EventPart\n                                                : AttributePart,\n                                });\n                            }\n                            else {\n                                parts.push({\n                                    type: ELEMENT_PART,\n                                    index: nodeIndex,\n                                });\n                            }\n                        }\n                    }\n                    for (const name of attrsToRemove) {\n                        node.removeAttribute(name);\n                    }\n                }\n                // TODO (justinfagnani): benchmark the regex against testing for each\n                // of the 3 raw text element names.\n                if (rawTextElement.test(node.tagName)) {\n                    // For raw text elements we need to split the text content on\n                    // markers, create a Text node for each segment, and create\n                    // a TemplatePart for each marker.\n                    const strings = node.textContent.split(marker);\n                    const lastIndex = strings.length - 1;\n                    if (lastIndex > 0) {\n                        node.textContent = trustedTypes\n                            ? trustedTypes.emptyScript\n                            : '';\n                        // Generate a new text node for each literal section\n                        // These nodes are also used as the markers for node parts\n                        // We can't use empty text nodes as markers because they're\n                        // normalized in some browsers (TODO: check)\n                        for (let i = 0; i < lastIndex; i++) {\n                            node.append(strings[i], createMarker());\n                            // Walk past the marker node we just added\n                            walker.nextNode();\n                            parts.push({ type: CHILD_PART, index: ++nodeIndex });\n                        }\n                        // Note because this marker is added after the walker's current\n                        // node, it will be walked to in the outer loop (and ignored), so\n                        // we don't need to adjust nodeIndex here\n                        node.append(strings[lastIndex], createMarker());\n                    }\n                }\n            }\n            else if (node.nodeType === 8) {\n                const data = node.data;\n                if (data === markerMatch) {\n                    parts.push({ type: CHILD_PART, index: nodeIndex });\n                }\n                else {\n                    let i = -1;\n                    while ((i = node.data.indexOf(marker, i + 1)) !== -1) {\n                        // Comment node has a binding marker inside, make an inactive part\n                        // The binding won't work, but subsequent bindings will\n                        // TODO (justinfagnani): consider whether it's even worth it to\n                        // make bindings in comments work\n                        parts.push({ type: COMMENT_PART, index: nodeIndex });\n                        // Move to the end of the match\n                        i += marker.length - 1;\n                    }\n                }\n            }\n            nodeIndex++;\n        }\n    }\n    // Overridden via `litHtmlPlatformSupport` to provide platform support.\n    static createElement(html, _options) {\n        const el = d.createElement('template');\n        el.innerHTML = html;\n        return el;\n    }\n}\nfunction resolveDirective(part, value, parent = part, attributeIndex) {\n    var _a, _b, _c;\n    var _d;\n    // Bail early if the value is explicitly noChange. Note, this means any\n    // nested directive is still attached and is not run.\n    if (value === noChange) {\n        return value;\n    }\n    let currentDirective = attributeIndex !== undefined\n        ? (_a = parent.__directives) === null || _a === void 0 ? void 0 : _a[attributeIndex] : parent.__directive;\n    const nextDirectiveConstructor = isPrimitive(value)\n        ? undefined\n        : value._$litDirective$;\n    if ((currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective.constructor) !== nextDirectiveConstructor) {\n        (_b = currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective._$setDirectiveConnected) === null || _b === void 0 ? void 0 : _b.call(currentDirective, false);\n        if (nextDirectiveConstructor === undefined) {\n            currentDirective = undefined;\n        }\n        else {\n            currentDirective = new nextDirectiveConstructor(part);\n            currentDirective._$initialize(part, parent, attributeIndex);\n        }\n        if (attributeIndex !== undefined) {\n            ((_c = (_d = parent).__directives) !== null && _c !== void 0 ? _c : (_d.__directives = []))[attributeIndex] = currentDirective;\n        }\n        else {\n            parent.__directive = currentDirective;\n        }\n    }\n    if (currentDirective !== undefined) {\n        value = resolveDirective(part, currentDirective._$resolve(part, value.values), currentDirective, attributeIndex);\n    }\n    return value;\n}\n/**\n * An updateable instance of a Template. Holds references to the Parts used to\n * update the template instance.\n */\nclass TemplateInstance {\n    constructor(template, parent) {\n        /** @internal */\n        this._parts = [];\n        /** @internal */\n        this._$disconnectableChildren = undefined;\n        this._$template = template;\n        this._$parent = parent;\n    }\n    // This method is separate from the constructor because we need to return a\n    // DocumentFragment and we don't want to hold onto it with an instance field.\n    _clone(options) {\n        var _a;\n        const { el: { content }, parts: parts, } = this._$template;\n        const fragment = ((_a = options === null || options === void 0 ? void 0 : options.creationScope) !== null && _a !== void 0 ? _a : d).importNode(content, true);\n        walker.currentNode = fragment;\n        let node = walker.nextNode();\n        let nodeIndex = 0;\n        let partIndex = 0;\n        let templatePart = parts[0];\n        while (templatePart !== undefined) {\n            if (nodeIndex === templatePart.index) {\n                let part;\n                if (templatePart.type === CHILD_PART) {\n                    part = new ChildPart(node, node.nextSibling, this, options);\n                }\n                else if (templatePart.type === ATTRIBUTE_PART) {\n                    part = new templatePart.ctor(node, templatePart.name, templatePart.strings, this, options);\n                }\n                else if (templatePart.type === ELEMENT_PART) {\n                    part = new ElementPart(node, this, options);\n                }\n                this._parts.push(part);\n                templatePart = parts[++partIndex];\n            }\n            if (nodeIndex !== (templatePart === null || templatePart === void 0 ? void 0 : templatePart.index)) {\n                node = walker.nextNode();\n                nodeIndex++;\n            }\n        }\n        return fragment;\n    }\n    _update(values) {\n        let i = 0;\n        for (const part of this._parts) {\n            if (part !== undefined) {\n                if (part.strings !== undefined) {\n                    part._$setValue(values, part, i);\n                    // The number of values the part consumes is part.strings.length - 1\n                    // since values are in between template spans. We increment i by 1\n                    // later in the loop, so increment it by part.strings.length - 2 here\n                    i += part.strings.length - 2;\n                }\n                else {\n                    part._$setValue(values[i]);\n                }\n            }\n            i++;\n        }\n    }\n}\nclass ChildPart {\n    constructor(startNode, endNode, parent, options) {\n        this.type = CHILD_PART;\n        // The following fields will be patched onto ChildParts when required by\n        // AsyncDirective\n        /** @internal */\n        this._$disconnectableChildren = undefined;\n        this._$startNode = startNode;\n        this._$endNode = endNode;\n        this._$parent = parent;\n        this.options = options;\n        if (ENABLE_EXTRA_SECURITY_HOOKS) {\n            // Explicitly initialize for consistent class shape.\n            this._textSanitizer = undefined;\n        }\n    }\n    /**\n     * Sets the connection state for any `AsyncDirectives` contained\n     * within this part and runs their `disconnected` or `reconnected`, according\n     * to the `isConnected` argument.\n     */\n    setConnected(isConnected) {\n        var _a;\n        (_a = this._$setChildPartConnected) === null || _a === void 0 ? void 0 : _a.call(this, isConnected);\n    }\n    /**\n     * The parent node into which the part renders its content.\n     *\n     * A ChildPart's content consists of a range of adjacent child nodes of\n     * `.parentNode`, possibly bordered by 'marker nodes' (`.startNode` and\n     * `.endNode`).\n     *\n     * - If both `.startNode` and `.endNode` are non-null, then the part's content\n     * consists of all siblings between `.startNode` and `.endNode`, exclusively.\n     *\n     * - If `.startNode` is non-null but `.endNode` is null, then the part's\n     * content consists of all siblings following `.startNode`, up to and\n     * including the last child of `.parentNode`. If `.endNode` is non-null, then\n     * `.startNode` will always be non-null.\n     *\n     * - If both `.endNode` and `.startNode` are null, then the part's content\n     * consists of all child nodes of `.parentNode`.\n     */\n    get parentNode() {\n        return wrap(this._$startNode).parentNode;\n    }\n    /**\n     * The part's leading marker node, if any. See `.parentNode` for more\n     * information.\n     */\n    get startNode() {\n        return this._$startNode;\n    }\n    /**\n     * The part's trailing marker node, if any. See `.parentNode` for more\n     * information.\n     */\n    get endNode() {\n        return this._$endNode;\n    }\n    _$setValue(value, directiveParent = this) {\n        value = resolveDirective(this, value, directiveParent);\n        if (isPrimitive(value)) {\n            // Non-rendering child values. It's important that these do not render\n            // empty text nodes to avoid issues with preventing default <slot>\n            // fallback content.\n            if (value === nothing || value == null || value === '') {\n                if (this._$committedValue !== nothing) {\n                    this._$clear();\n                }\n                this._$committedValue = nothing;\n            }\n            else if (value !== this._$committedValue && value !== noChange) {\n                this._commitText(value);\n            }\n        }\n        else if (value._$litType$ !== undefined) {\n            this._commitTemplateResult(value);\n        }\n        else if (value.nodeType !== undefined) {\n            this._commitNode(value);\n        }\n        else if (isIterable(value)) {\n            this._commitIterable(value);\n        }\n        else {\n            // Fallback, will render the string representation\n            this._commitText(value);\n        }\n    }\n    _insert(node, ref = this._$endNode) {\n        return wrap(wrap(this._$startNode).parentNode).insertBefore(node, ref);\n    }\n    _commitNode(value) {\n        var _a;\n        if (this._$committedValue !== value) {\n            this._$clear();\n            if (ENABLE_EXTRA_SECURITY_HOOKS &&\n                sanitizerFactoryInternal !== noopSanitizer) {\n                const parentNodeName = (_a = this._$startNode.parentNode) === null || _a === void 0 ? void 0 : _a.nodeName;\n                if (parentNodeName === 'STYLE' || parentNodeName === 'SCRIPT') {\n                    this._insert(new Text('/* lit-html will not write ' +\n                        'TemplateResults to scripts and styles */'));\n                    return;\n                }\n            }\n            this._$committedValue = this._insert(value);\n        }\n    }\n    _commitText(value) {\n        const node = wrap(this._$startNode).nextSibling;\n        // TODO(justinfagnani): Can we just check if this._$committedValue is primitive?\n        if (node !== null &&\n            node.nodeType === 3 /* Node.TEXT_NODE */ &&\n            (this._$endNode === null\n                ? wrap(node).nextSibling === null\n                : node === wrap(this._$endNode).previousSibling)) {\n            if (ENABLE_EXTRA_SECURITY_HOOKS) {\n                if (this._textSanitizer === undefined) {\n                    this._textSanitizer = createSanitizer(node, 'data', 'property');\n                }\n                value = this._textSanitizer(value);\n            }\n            // If we only have a single text node between the markers, we can just\n            // set its value, rather than replacing it.\n            node.data = value;\n        }\n        else {\n            if (ENABLE_EXTRA_SECURITY_HOOKS) {\n                const textNode = document.createTextNode('');\n                this._commitNode(textNode);\n                // When setting text content, for security purposes it matters a lot\n                // what the parent is. For example, <style> and <script> need to be\n                // handled with care, while <span> does not. So first we need to put a\n                // text node into the document, then we can sanitize its contentx.\n                if (this._textSanitizer === undefined) {\n                    this._textSanitizer = createSanitizer(textNode, 'data', 'property');\n                }\n                value = this._textSanitizer(value);\n                textNode.data = value;\n            }\n            else {\n                this._commitNode(d.createTextNode(value));\n            }\n        }\n        this._$committedValue = value;\n    }\n    _commitTemplateResult(result) {\n        var _a;\n        const { values, _$litType$ } = result;\n        // If $litType$ is a number, result is a plain TemplateResult and we get\n        // the template from the template cache. If not, result is a\n        // CompiledTemplateResult and _$litType$ is a CompiledTemplate and we need\n        // to create the <template> element the first time we see it.\n        const template = typeof _$litType$ === 'number'\n            ? this._$getTemplate(result)\n            : (_$litType$.el === undefined &&\n                (_$litType$.el = Template.createElement(_$litType$.h, this.options)),\n                _$litType$);\n        if (((_a = this._$committedValue) === null || _a === void 0 ? void 0 : _a._$template) === template) {\n            this._$committedValue._update(values);\n        }\n        else {\n            const instance = new TemplateInstance(template, this);\n            const fragment = instance._clone(this.options);\n            instance._update(values);\n            this._commitNode(fragment);\n            this._$committedValue = instance;\n        }\n    }\n    // Overridden via `litHtmlPlatformSupport` to provide platform support.\n    /** @internal */\n    _$getTemplate(result) {\n        let template = templateCache.get(result.strings);\n        if (template === undefined) {\n            templateCache.set(result.strings, (template = new Template(result)));\n        }\n        return template;\n    }\n    _commitIterable(value) {\n        // For an Iterable, we create a new InstancePart per item, then set its\n        // value to the item. This is a little bit of overhead for every item in\n        // an Iterable, but it lets us recurse easily and efficiently update Arrays\n        // of TemplateResults that will be commonly returned from expressions like:\n        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n        // If value is an array, then the previous render was of an\n        // iterable and value will contain the ChildParts from the previous\n        // render. If value is not an array, clear this part and make a new\n        // array for ChildParts.\n        if (!isArray(this._$committedValue)) {\n            this._$committedValue = [];\n            this._$clear();\n        }\n        // Lets us keep track of how many items we stamped so we can clear leftover\n        // items from a previous render\n        const itemParts = this._$committedValue;\n        let partIndex = 0;\n        let itemPart;\n        for (const item of value) {\n            if (partIndex === itemParts.length) {\n                // If no existing part, create a new one\n                // TODO (justinfagnani): test perf impact of always creating two parts\n                // instead of sharing parts between nodes\n                // https://github.com/lit/lit/issues/1266\n                itemParts.push((itemPart = new ChildPart(this._insert(createMarker()), this._insert(createMarker()), this, this.options)));\n            }\n            else {\n                // Reuse an existing part\n                itemPart = itemParts[partIndex];\n            }\n            itemPart._$setValue(item);\n            partIndex++;\n        }\n        if (partIndex < itemParts.length) {\n            // itemParts always have end nodes\n            this._$clear(itemPart && wrap(itemPart._$endNode).nextSibling, partIndex);\n            // Truncate the parts array so _value reflects the current state\n            itemParts.length = partIndex;\n        }\n    }\n    /**\n     * Removes the nodes contained within this Part from the DOM.\n     *\n     * @param start Start node to clear from, for clearing a subset of the part's\n     *     DOM (used when truncating iterables)\n     * @param from  When `start` is specified, the index within the iterable from\n     *     which ChildParts are being removed, used for disconnecting directives in\n     *     those Parts.\n     *\n     * @internal\n     */\n    _$clear(start = wrap(this._$startNode).nextSibling, from) {\n        var _a;\n        (_a = this._$setChildPartConnected) === null || _a === void 0 ? void 0 : _a.call(this, false, true, from);\n        while (start && start !== this._$endNode) {\n            const n = wrap(start).nextSibling;\n            wrap(start).remove();\n            start = n;\n        }\n    }\n}\nclass AttributePart {\n    constructor(element, name, strings, parent, options) {\n        this.type = ATTRIBUTE_PART;\n        /** @internal */\n        this._$committedValue = nothing;\n        /** @internal */\n        this._$disconnectableChildren = undefined;\n        /** @internal */\n        this._setDirectiveConnected = undefined;\n        this.element = element;\n        this.name = name;\n        this._$parent = parent;\n        this.options = options;\n        if (strings.length > 2 || strings[0] !== '' || strings[1] !== '') {\n            this._$committedValue = new Array(strings.length - 1).fill(nothing);\n            this.strings = strings;\n        }\n        else {\n            this._$committedValue = nothing;\n        }\n        if (ENABLE_EXTRA_SECURITY_HOOKS) {\n            this._sanitizer = undefined;\n        }\n    }\n    get tagName() {\n        return this.element.tagName;\n    }\n    /**\n     * Sets the value of this part by resolving the value from possibly multiple\n     * values and static strings and committing it to the DOM.\n     * If this part is single-valued, `this._strings` will be undefined, and the\n     * method will be called with a single value argument. If this part is\n     * multi-value, `this._strings` will be defined, and the method is called\n     * with the value array of the part's owning TemplateInstance, and an offset\n     * into the value array from which the values should be read.\n     * This method is overloaded this way to eliminate short-lived array slices\n     * of the template instance values, and allow a fast-path for single-valued\n     * parts.\n     *\n     * @param value The part value, or an array of values for multi-valued parts\n     * @param valueIndex the index to start reading values from. `undefined` for\n     *   single-valued parts\n     * @param noCommit causes the part to not commit its value to the DOM. Used\n     *   in hydration to prime attribute parts with their first-rendered value,\n     *   but not set the attribute, and in SSR to no-op the DOM operation and\n     *   capture the value for serialization.\n     *\n     * @internal\n     */\n    _$setValue(value, directiveParent = this, valueIndex, noCommit) {\n        const strings = this.strings;\n        // Whether any of the values has changed, for dirty-checking\n        let change = false;\n        if (strings === undefined) {\n            // Single-value binding case\n            value = resolveDirective(this, value, directiveParent, 0);\n            change =\n                !isPrimitive(value) ||\n                    (value !== this._$committedValue && value !== noChange);\n            if (change) {\n                this._$committedValue = value;\n            }\n        }\n        else {\n            // Interpolation case\n            const values = value;\n            value = strings[0];\n            let i, v;\n            for (i = 0; i < strings.length - 1; i++) {\n                v = resolveDirective(this, values[valueIndex + i], directiveParent, i);\n                if (v === noChange) {\n                    // If the user-provided value is `noChange`, use the previous value\n                    v = this._$committedValue[i];\n                }\n                change || (change = !isPrimitive(v) || v !== this._$committedValue[i]);\n                if (v === nothing) {\n                    value = nothing;\n                }\n                else if (value !== nothing) {\n                    value += (v !== null && v !== void 0 ? v : '') + strings[i + 1];\n                }\n                // We always record each value, even if one is `nothing`, for future\n                // change detection.\n                this._$committedValue[i] = v;\n            }\n        }\n        if (change && !noCommit) {\n            this._commitValue(value);\n        }\n    }\n    /** @internal */\n    _commitValue(value) {\n        if (value === nothing) {\n            wrap(this.element).removeAttribute(this.name);\n        }\n        else {\n            if (ENABLE_EXTRA_SECURITY_HOOKS) {\n                if (this._sanitizer === undefined) {\n                    this._sanitizer = sanitizerFactoryInternal(this.element, this.name, 'attribute');\n                }\n                value = this._sanitizer(value !== null && value !== void 0 ? value : '');\n            }\n            wrap(this.element).setAttribute(this.name, (value !== null && value !== void 0 ? value : ''));\n        }\n    }\n}\nclass PropertyPart extends AttributePart {\n    constructor() {\n        super(...arguments);\n        this.type = PROPERTY_PART;\n    }\n    /** @internal */\n    _commitValue(value) {\n        if (ENABLE_EXTRA_SECURITY_HOOKS) {\n            if (this._sanitizer === undefined) {\n                this._sanitizer = sanitizerFactoryInternal(this.element, this.name, 'property');\n            }\n            value = this._sanitizer(value);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.element[this.name] = value === nothing ? undefined : value;\n    }\n}\nclass BooleanAttributePart extends AttributePart {\n    constructor() {\n        super(...arguments);\n        this.type = BOOLEAN_ATTRIBUTE_PART;\n    }\n    /** @internal */\n    _commitValue(value) {\n        if (value && value !== nothing) {\n            wrap(this.element).setAttribute(this.name, '');\n        }\n        else {\n            wrap(this.element).removeAttribute(this.name);\n        }\n    }\n}\nclass EventPart extends AttributePart {\n    constructor() {\n        super(...arguments);\n        this.type = EVENT_PART;\n    }\n    // EventPart does not use the base _$setValue/_resolveValue implementation\n    // since the dirty checking is more complex\n    /** @internal */\n    _$setValue(newListener, directiveParent = this) {\n        var _a;\n        newListener = (_a = resolveDirective(this, newListener, directiveParent, 0)) !== null && _a !== void 0 ? _a : nothing;\n        if (newListener === noChange) {\n            return;\n        }\n        const oldListener = this._$committedValue;\n        // If the new value is nothing or any options change we have to remove the\n        // part as a listener.\n        const shouldRemoveListener = (newListener === nothing && oldListener !== nothing) ||\n            newListener.capture !==\n                oldListener.capture ||\n            newListener.once !==\n                oldListener.once ||\n            newListener.passive !==\n                oldListener.passive;\n        // If the new value is not nothing and we removed the listener, we have\n        // to add the part as a listener.\n        const shouldAddListener = newListener !== nothing &&\n            (oldListener === nothing || shouldRemoveListener);\n        if (shouldRemoveListener) {\n            this.element.removeEventListener(this.name, this, oldListener);\n        }\n        if (shouldAddListener) {\n            // Beware: IE11 and Chrome 41 don't like using the listener as the\n            // options object. Figure out how to deal w/ this in IE11 - maybe\n            // patch addEventListener?\n            this.element.addEventListener(this.name, this, newListener);\n        }\n        this._$committedValue = newListener;\n    }\n    handleEvent(event) {\n        var _a, _b;\n        if (typeof this._$committedValue === 'function') {\n            // TODO (justinfagnani): do we need to default to this.element?\n            // It'll always be the same as `e.currentTarget`.\n            this._$committedValue.call((_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : this.element, event);\n        }\n        else {\n            this._$committedValue.handleEvent(event);\n        }\n    }\n}\nclass ElementPart {\n    constructor(element, parent, options) {\n        this.element = element;\n        this.type = ELEMENT_PART;\n        /** @internal */\n        this._$disconnectableChildren = undefined;\n        /** @internal */\n        this._setDirectiveConnected = undefined;\n        this._$parent = parent;\n        this.options = options;\n    }\n    _$setValue(value) {\n        resolveDirective(this, value);\n    }\n}\n/**\n * END USERS SHOULD NOT RELY ON THIS OBJECT.\n *\n * Private exports for use by other Lit packages, not intended for use by\n * external users.\n *\n * We currently do not make a mangled rollup build of the lit-ssr code. In order\n * to keep a number of (otherwise private) top-level exports  mangled in the\n * client side code, we export a _\u03A3 object containing those members (or\n * helper methods for accessing private fields of those members), and then\n * re-export them for use in lit-ssr. This keeps lit-ssr agnostic to whether the\n * client-side code is being used in `dev` mode or `prod` mode.\n *\n * This has a unique name, to disambiguate it from private exports in\n * lit-element, which re-exports all of lit-html.\n *\n * @private\n */\nexport const _\u03A3 = {\n    // Used in lit-ssr\n    _boundAttributeSuffix: boundAttributeSuffix,\n    _marker: marker,\n    _markerMatch: markerMatch,\n    _HTML_RESULT: HTML_RESULT,\n    _getTemplateHtml: getTemplateHtml,\n    // Used in hydrate\n    _TemplateInstance: TemplateInstance,\n    _isIterable: isIterable,\n    _resolveDirective: resolveDirective,\n    // Used in tests and private-ssr-support\n    _ChildPart: ChildPart,\n    _AttributePart: AttributePart,\n    _BooleanAttributePart: BooleanAttributePart,\n    _EventPart: EventPart,\n    _PropertyPart: PropertyPart,\n    _ElementPart: ElementPart,\n};\n// Apply polyfills if available\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(_d = (_c = globalThis)['litHtmlPlatformSupport']) === null || _d === void 0 ? void 0 : _d.call(_c, Template, ChildPart);\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for lit-html usage.\n// TODO(justinfagnani): inject version number at build time\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n((_e = (_f = globalThis)['litHtmlVersions']) !== null && _e !== void 0 ? _e : (_f['litHtmlVersions'] = [])).push('2.0.0-rc.3');\n//# sourceMappingURL=lit-html.js.map"],
  "mappings": ";AAAA,AAKA,IAAI;AAAJ,IAAQ;AAAR,IAAY;AAAZ,IAAgB;AAAhB,IAAoB;AACpB,IAAI;AACJ,IAAM,WAAW;AACjB,IAAM,8BAA8B;AACpC,IAAM,0BAA0B;AAChC,IAAI,UAAU;AACV,UAAQ,KAAK;AAAA;AAEjB,IAAM,OAAO,2BAA6B,OAAK,OAAO,cAAc,QAAQ,OAAO,SAAS,SAAS,GAAG,UAClG,OAAK,OAAO,cAAc,QAAQ,OAAO,SAAS,SAAS,GAAG,aAAa,OAC3E,OAAO,SAAS,OAChB,CAAC,SAAS;AAChB,IAAM,eAAe,WAAW;AAShC,IAAM,SAAS,eACT,aAAa,aAAa,YAAY;AAAA,EACpC,YAAY,CAAC,MAAM;AAAA,KAErB;AACN,IAAM,mBAAmB,CAAC,UAAU;AACpC,IAAM,gBAAgB,CAAC,OAAO,OAAO,UAAU;AAE/C,IAAM,eAAe,CAAC,iBAAiB;AACnC,MAAI,CAAC,6BAA6B;AAC9B;AAAA;AAEJ,MAAI,6BAA6B,eAAe;AAC5C,UAAM,IAAI,MAAM;AAAA;AAGpB,6BAA2B;AAAA;AAK/B,IAAM,gDAAgD,MAAM;AACxD,6BAA2B;AAAA;AAE/B,IAAM,kBAAkB,CAAC,MAAM,MAAM,SAAS;AAC1C,SAAO,yBAAyB,MAAM,MAAM;AAAA;AAIhD,IAAM,uBAAuB;AAK7B,IAAM,SAAS,OAAO,OAAO,KAAK,UAAU,MAAM;AAElD,IAAM,cAAc,MAAM;AAG1B,IAAM,aAAa,IAAI;AACvB,IAAM,IAAI;AAEV,IAAM,eAAe,CAAC,IAAI,OAAO,EAAE,cAAc;AACjD,IAAM,cAAc,CAAC,UAAU,UAAU,QAAS,OAAO,SAAS,YAAY,OAAO,SAAS;AAC9F,IAAM,UAAU,MAAM;AACtB,IAAM,aAAa,CAAC,UAAU;AAC1B,MAAI;AACJ,SAAO,QAAQ,UAEX,OAAS,QAAK,WAAW,QAAQ,QAAO,SAAS,SAAS,IAAG,OAAO,eAAe;AAAA;AAE3F,IAAM,aAAa;AAAA;AACnB,IAAM,kBAAkB;AAAA;AACxB,IAAM,YAAY;AAclB,IAAM,eAAe;AACrB,IAAM,gBAAgB;AACtB,IAAM,WAAW;AACjB,IAAM,mBAAmB;AACzB,IAAM,kBAAkB;AAIxB,IAAM,mBAAmB;AAuBzB,IAAM,cAAc,IAAI,OAAO,KAAK,iBAAiB,eAAe,eAAe,iBAAiB,+BAA+B;AACnI,IAAM,eAAe;AACrB,IAAM,iBAAiB;AACvB,IAAM,oBAAoB;AAC1B,IAAM,aAAa;AACnB,IAAM,0BAA0B;AAChC,IAAM,0BAA0B;AAOhC,IAAM,iBAAiB;AAEvB,IAAM,cAAc;AACpB,IAAM,aAAa;AAGnB,IAAM,iBAAiB;AACvB,IAAM,aAAa;AACnB,IAAM,gBAAgB;AACtB,IAAM,yBAAyB;AAC/B,IAAM,aAAa;AACnB,IAAM,eAAe;AACrB,IAAM,eAAe;AAKrB,IAAM,MAAM,CAAC,eAAe,CAAC,YAAY,WAAY;AAAA,EACjD;AAAA,EACA;AAAA,EACA;AAAA;AAMG,IAAM,OAAO,IAAI;AAKjB,IAAM,MAAM,IAAI;AAKhB,IAAM,WAAW,OAAO,IAAI;AAI5B,IAAM,UAAU,OAAO,IAAI;AAQlC,IAAM,gBAAgB,IAAI;AAOnB,IAAM,SAAS,CAAC,OAAO,WAAW,YAAY;AACjD,MAAI,KAAI;AACR,QAAM,gBAAiB,OAAK,YAAY,QAAQ,YAAY,SAAS,SAAS,QAAQ,kBAAkB,QAAQ,QAAO,SAAS,MAAK;AAErI,MAAI,OAAO,cAAc;AACzB,MAAI,SAAS,QAAW;AACpB,UAAM,UAAW,OAAK,YAAY,QAAQ,YAAY,SAAS,SAAS,QAAQ,kBAAkB,QAAQ,QAAO,SAAS,MAAK;AAE/H,kBAAc,aAAa,OAAO,IAAI,UAAU,UAAU,aAAa,gBAAgB,UAAU,SAAS,QAAW;AAAA;AAEzH,OAAK,WAAW;AAChB,SAAO;AAAA;AAEX,IAAI,6BAA6B;AAC7B,SAAO,eAAe;AACtB,SAAO,kBAAkB;AACzB,MAAI,UAAU;AACV,WAAO,gDAAgD;AAAA;AAAA;AAG/D,IAAM,SAAS,EAAE,iBAAiB,GAAG,KAA6C,MAAM;AACxF,IAAI,2BAA2B;AAa/B,IAAM,kBAAkB,CAAC,SAAS,SAAS;AAOvC,QAAM,IAAI,QAAQ,SAAS;AAI3B,QAAM,YAAY;AAClB,MAAI,QAAO,SAAS,aAAa,UAAU;AAI3C,MAAI;AAGJ,MAAI,QAAQ;AACZ,WAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AACxB,UAAM,IAAI,QAAQ;AAMlB,QAAI,mBAAmB;AACvB,QAAI;AACJ,QAAI,YAAY;AAChB,QAAI;AAGJ,WAAO,YAAY,EAAE,QAAQ;AAEzB,YAAM,YAAY;AAClB,cAAQ,MAAM,KAAK;AACnB,UAAI,UAAU,MAAM;AAChB;AAAA;AAEJ,kBAAY,MAAM;AAClB,UAAI,UAAU,cAAc;AACxB,YAAI,MAAM,mBAAmB,OAAO;AAChC,kBAAQ;AAAA,mBAEH,MAAM,mBAAmB,QAAW;AAEzC,kBAAQ;AAAA,mBAEH,MAAM,cAAc,QAAW;AACpC,cAAI,eAAe,KAAK,MAAM,YAAY;AAGtC,8BAAkB,IAAI,OAAO,KAAK,MAAM,aAAa;AAAA;AAEzD,kBAAQ;AAAA,mBAEH,MAAM,sBAAsB,QAAW;AAE5C,kBAAQ;AAAA;AAAA,iBAGP,UAAU,aAAa;AAC5B,YAAI,MAAM,kBAAkB,KAAK;AAG7B,kBAAQ,oBAAoB,QAAQ,oBAAoB,SAAS,kBAAkB;AAGnF,6BAAmB;AAAA,mBAEd,MAAM,oBAAoB,QAAW;AAE1C,6BAAmB;AAAA,eAElB;AACD,6BAAmB,MAAM,YAAY,MAAM,mBAAmB;AAC9D,qBAAW,MAAM;AACjB,kBACI,MAAM,gBAAgB,SAChB,cACA,MAAM,gBAAgB,MAClB,0BACA;AAAA;AAAA,iBAGb,UAAU,2BACf,UAAU,yBAAyB;AACnC,gBAAQ;AAAA,iBAEH,UAAU,mBAAmB,UAAU,kBAAkB;AAC9D,gBAAQ;AAAA,aAEP;AAGD,gBAAQ;AACR,0BAAkB;AAAA;AAAA;AAG1B,QAAI,UAAU;AAIV,cAAQ,OAAO,qBAAqB,MAChC,UAAU,eACV,UAAU,2BACV,UAAU,yBAAyB;AAAA;AAc3C,UAAM,MAAM,UAAU,eAAe,QAAQ,IAAI,GAAG,WAAW,QAAQ,MAAM;AAC7E,aACI,UAAU,eACJ,IAAI,aACJ,oBAAoB,IACf,WAAU,KAAK,WACd,EAAE,MAAM,GAAG,oBACP,uBACA,EAAE,MAAM,qBACZ,SACA,MACF,IACE,SACC,sBAAqB,KAAM,WAAU,KAAK,SAAY,KAAK;AAAA;AAEhF,QAAM,aAAa,QAAQ,SAAQ,MAAM,SAAU,UAAS,aAAa,WAAW;AAEpF,SAAO;AAAA,IACH,WAAW,SACL,OAAO,WAAW,cAClB;AAAA,IACN;AAAA;AAAA;AAGR,qBAAe;AAAA,EACX,YAAY,EAAE,SAAS,YAAY,QAAQ,SAAS;AAEhD,SAAK,QAAQ;AACb,QAAI;AACJ,QAAI,YAAY;AAChB,QAAI,gBAAgB;AACpB,UAAM,YAAY,QAAQ,SAAS;AACnC,UAAM,QAAQ,KAAK;AAEnB,UAAM,CAAC,OAAM,aAAa,gBAAgB,SAAS;AACnD,SAAK,KAAK,SAAS,cAAc,OAAM;AACvC,WAAO,cAAc,KAAK,GAAG;AAE7B,QAAI,SAAS,YAAY;AACrB,YAAM,UAAU,KAAK,GAAG;AACxB,YAAM,aAAa,QAAQ;AAC3B,iBAAW;AACX,cAAQ,OAAO,GAAG,WAAW;AAAA;AAGjC,WAAQ,QAAO,OAAO,gBAAgB,QAAQ,MAAM,SAAS,WAAW;AACpE,UAAI,KAAK,aAAa,GAAG;AAIrB,YAAI,KAAK,iBAAiB;AAItB,gBAAM,gBAAgB;AACtB,qBAAW,QAAQ,KAAK,qBAAqB;AAQzC,gBAAI,KAAK,SAAS,yBACd,KAAK,WAAW,SAAS;AACzB,oBAAM,WAAW,UAAU;AAC3B,4BAAc,KAAK;AACnB,kBAAI,aAAa,QAAW;AAExB,sBAAM,QAAQ,KAAK,aAAa,SAAS,gBAAgB;AACzD,sBAAM,UAAU,MAAM,MAAM;AAC5B,sBAAM,IAAI,eAAe,KAAK;AAC9B,sBAAM,KAAK;AAAA,kBACP,MAAM;AAAA,kBACN,OAAO;AAAA,kBACP,MAAM,EAAE;AAAA,kBACR,SAAS;AAAA,kBACT,MAAM,EAAE,OAAO,MACT,eACA,EAAE,OAAO,MACL,uBACA,EAAE,OAAO,MACL,YACA;AAAA;AAAA,qBAGjB;AACD,sBAAM,KAAK;AAAA,kBACP,MAAM;AAAA,kBACN,OAAO;AAAA;AAAA;AAAA;AAAA;AAKvB,qBAAW,QAAQ,eAAe;AAC9B,iBAAK,gBAAgB;AAAA;AAAA;AAK7B,YAAI,eAAe,KAAK,KAAK,UAAU;AAInC,gBAAM,WAAU,KAAK,YAAY,MAAM;AACvC,gBAAM,YAAY,SAAQ,SAAS;AACnC,cAAI,YAAY,GAAG;AACf,iBAAK,cAAc,eACb,aAAa,cACb;AAKN,qBAAS,IAAI,GAAG,IAAI,WAAW,KAAK;AAChC,mBAAK,OAAO,SAAQ,IAAI;AAExB,qBAAO;AACP,oBAAM,KAAK,EAAE,MAAM,YAAY,OAAO,EAAE;AAAA;AAK5C,iBAAK,OAAO,SAAQ,YAAY;AAAA;AAAA;AAAA,iBAInC,KAAK,aAAa,GAAG;AAC1B,cAAM,OAAO,KAAK;AAClB,YAAI,SAAS,aAAa;AACtB,gBAAM,KAAK,EAAE,MAAM,YAAY,OAAO;AAAA,eAErC;AACD,cAAI,IAAI;AACR,iBAAQ,KAAI,KAAK,KAAK,QAAQ,QAAQ,IAAI,QAAQ,IAAI;AAKlD,kBAAM,KAAK,EAAE,MAAM,cAAc,OAAO;AAExC,iBAAK,OAAO,SAAS;AAAA;AAAA;AAAA;AAIjC;AAAA;AAAA;AAAA,SAID,cAAc,OAAM,UAAU;AACjC,UAAM,KAAK,EAAE,cAAc;AAC3B,OAAG,YAAY;AACf,WAAO;AAAA;AAAA;AAGf,0BAA0B,MAAM,OAAO,SAAS,MAAM,gBAAgB;AAClE,MAAI,KAAI,KAAI;AACZ,MAAI;AAGJ,MAAI,UAAU,UAAU;AACpB,WAAO;AAAA;AAEX,MAAI,mBAAmB,mBAAmB,SACnC,OAAK,OAAO,kBAAkB,QAAQ,QAAO,SAAS,SAAS,IAAG,kBAAkB,OAAO;AAClG,QAAM,2BAA2B,YAAY,SACvC,SACA,MAAM;AACZ,MAAK,sBAAqB,QAAQ,qBAAqB,SAAS,SAAS,iBAAiB,iBAAiB,0BAA0B;AACjI,IAAC,OAAK,qBAAqB,QAAQ,qBAAqB,SAAS,SAAS,iBAAiB,6BAA6B,QAAQ,QAAO,SAAS,SAAS,IAAG,KAAK,kBAAkB;AACnL,QAAI,6BAA6B,QAAW;AACxC,yBAAmB;AAAA,WAElB;AACD,yBAAmB,IAAI,yBAAyB;AAChD,uBAAiB,aAAa,MAAM,QAAQ;AAAA;AAEhD,QAAI,mBAAmB,QAAW;AAC9B,MAAE,QAAM,OAAK,QAAQ,kBAAkB,QAAQ,QAAO,SAAS,MAAM,IAAG,eAAe,IAAK,kBAAkB;AAAA,WAE7G;AACD,aAAO,cAAc;AAAA;AAAA;AAG7B,MAAI,qBAAqB,QAAW;AAChC,YAAQ,iBAAiB,MAAM,iBAAiB,UAAU,MAAM,MAAM,SAAS,kBAAkB;AAAA;AAErG,SAAO;AAAA;AAMX,6BAAuB;AAAA,EACnB,YAAY,UAAU,QAAQ;AAE1B,SAAK,SAAS;AAEd,SAAK,2BAA2B;AAChC,SAAK,aAAa;AAClB,SAAK,WAAW;AAAA;AAAA,EAIpB,OAAO,SAAS;AACZ,QAAI;AACJ,UAAM,EAAE,IAAI,EAAE,WAAW,UAAkB,KAAK;AAChD,UAAM,WAAa,QAAK,YAAY,QAAQ,YAAY,SAAS,SAAS,QAAQ,mBAAmB,QAAQ,QAAO,SAAS,MAAK,GAAG,WAAW,SAAS;AACzJ,WAAO,cAAc;AACrB,QAAI,OAAO,OAAO;AAClB,QAAI,YAAY;AAChB,QAAI,YAAY;AAChB,QAAI,eAAe,MAAM;AACzB,WAAO,iBAAiB,QAAW;AAC/B,UAAI,cAAc,aAAa,OAAO;AAClC,YAAI;AACJ,YAAI,aAAa,SAAS,YAAY;AAClC,iBAAO,IAAI,UAAU,MAAM,KAAK,aAAa,MAAM;AAAA,mBAE9C,aAAa,SAAS,gBAAgB;AAC3C,iBAAO,IAAI,aAAa,KAAK,MAAM,aAAa,MAAM,aAAa,SAAS,MAAM;AAAA,mBAE7E,aAAa,SAAS,cAAc;AACzC,iBAAO,IAAI,YAAY,MAAM,MAAM;AAAA;AAEvC,aAAK,OAAO,KAAK;AACjB,uBAAe,MAAM,EAAE;AAAA;AAE3B,UAAI,cAAe,kBAAiB,QAAQ,iBAAiB,SAAS,SAAS,aAAa,QAAQ;AAChG,eAAO,OAAO;AACd;AAAA;AAAA;AAGR,WAAO;AAAA;AAAA,EAEX,QAAQ,QAAQ;AACZ,QAAI,IAAI;AACR,eAAW,QAAQ,KAAK,QAAQ;AAC5B,UAAI,SAAS,QAAW;AACpB,YAAI,KAAK,YAAY,QAAW;AAC5B,eAAK,WAAW,QAAQ,MAAM;AAI9B,eAAK,KAAK,QAAQ,SAAS;AAAA,eAE1B;AACD,eAAK,WAAW,OAAO;AAAA;AAAA;AAG/B;AAAA;AAAA;AAAA;AAIZ,sBAAgB;AAAA,EACZ,YAAY,WAAW,SAAS,QAAQ,SAAS;AAC7C,SAAK,OAAO;AAIZ,SAAK,2BAA2B;AAChC,SAAK,cAAc;AACnB,SAAK,YAAY;AACjB,SAAK,WAAW;AAChB,SAAK,UAAU;AACf,QAAI,6BAA6B;AAE7B,WAAK,iBAAiB;AAAA;AAAA;AAAA,EAQ9B,aAAa,aAAa;AACtB,QAAI;AACJ,IAAC,OAAK,KAAK,6BAA6B,QAAQ,QAAO,SAAS,SAAS,IAAG,KAAK,MAAM;AAAA;AAAA,MAoBvF,aAAa;AACb,WAAO,KAAK,KAAK,aAAa;AAAA;AAAA,MAM9B,YAAY;AACZ,WAAO,KAAK;AAAA;AAAA,MAMZ,UAAU;AACV,WAAO,KAAK;AAAA;AAAA,EAEhB,WAAW,OAAO,kBAAkB,MAAM;AACtC,YAAQ,iBAAiB,MAAM,OAAO;AACtC,QAAI,YAAY,QAAQ;AAIpB,UAAI,UAAU,WAAW,SAAS,QAAQ,UAAU,IAAI;AACpD,YAAI,KAAK,qBAAqB,SAAS;AACnC,eAAK;AAAA;AAET,aAAK,mBAAmB;AAAA,iBAEnB,UAAU,KAAK,oBAAoB,UAAU,UAAU;AAC5D,aAAK,YAAY;AAAA;AAAA,eAGhB,MAAM,eAAe,QAAW;AACrC,WAAK,sBAAsB;AAAA,eAEtB,MAAM,aAAa,QAAW;AACnC,WAAK,YAAY;AAAA,eAEZ,WAAW,QAAQ;AACxB,WAAK,gBAAgB;AAAA,WAEpB;AAED,WAAK,YAAY;AAAA;AAAA;AAAA,EAGzB,QAAQ,MAAM,MAAM,KAAK,WAAW;AAChC,WAAO,KAAK,KAAK,KAAK,aAAa,YAAY,aAAa,MAAM;AAAA;AAAA,EAEtE,YAAY,OAAO;AACf,QAAI;AACJ,QAAI,KAAK,qBAAqB,OAAO;AACjC,WAAK;AACL,UAAI,+BACA,6BAA6B,eAAe;AAC5C,cAAM,iBAAkB,OAAK,KAAK,YAAY,gBAAgB,QAAQ,QAAO,SAAS,SAAS,IAAG;AAClG,YAAI,mBAAmB,WAAW,mBAAmB,UAAU;AAC3D,eAAK,QAAQ,IAAI,KAAK;AAEtB;AAAA;AAAA;AAGR,WAAK,mBAAmB,KAAK,QAAQ;AAAA;AAAA;AAAA,EAG7C,YAAY,OAAO;AACf,UAAM,OAAO,KAAK,KAAK,aAAa;AAEpC,QAAI,SAAS,QACT,KAAK,aAAa,KACjB,MAAK,cAAc,OACd,KAAK,MAAM,gBAAgB,OAC3B,SAAS,KAAK,KAAK,WAAW,kBAAkB;AACtD,UAAI,6BAA6B;AAC7B,YAAI,KAAK,mBAAmB,QAAW;AACnC,eAAK,iBAAiB,gBAAgB,MAAM,QAAQ;AAAA;AAExD,gBAAQ,KAAK,eAAe;AAAA;AAIhC,WAAK,OAAO;AAAA,WAEX;AACD,UAAI,6BAA6B;AAC7B,cAAM,WAAW,SAAS,eAAe;AACzC,aAAK,YAAY;AAKjB,YAAI,KAAK,mBAAmB,QAAW;AACnC,eAAK,iBAAiB,gBAAgB,UAAU,QAAQ;AAAA;AAE5D,gBAAQ,KAAK,eAAe;AAC5B,iBAAS,OAAO;AAAA,aAEf;AACD,aAAK,YAAY,EAAE,eAAe;AAAA;AAAA;AAG1C,SAAK,mBAAmB;AAAA;AAAA,EAE5B,sBAAsB,QAAQ;AAC1B,QAAI;AACJ,UAAM,EAAE,QAAQ,eAAe;AAK/B,UAAM,WAAW,OAAO,eAAe,WACjC,KAAK,cAAc,UAClB,YAAW,OAAO,UAChB,YAAW,KAAK,SAAS,cAAc,WAAW,GAAG,KAAK,WAC3D;AACR,QAAM,QAAK,KAAK,sBAAsB,QAAQ,QAAO,SAAS,SAAS,IAAG,gBAAgB,UAAU;AAChG,WAAK,iBAAiB,QAAQ;AAAA,WAE7B;AACD,YAAM,WAAW,IAAI,iBAAiB,UAAU;AAChD,YAAM,WAAW,SAAS,OAAO,KAAK;AACtC,eAAS,QAAQ;AACjB,WAAK,YAAY;AACjB,WAAK,mBAAmB;AAAA;AAAA;AAAA,EAKhC,cAAc,QAAQ;AAClB,QAAI,WAAW,cAAc,IAAI,OAAO;AACxC,QAAI,aAAa,QAAW;AACxB,oBAAc,IAAI,OAAO,SAAU,WAAW,IAAI,SAAS;AAAA;AAE/D,WAAO;AAAA;AAAA,EAEX,gBAAgB,OAAO;AAUnB,QAAI,CAAC,QAAQ,KAAK,mBAAmB;AACjC,WAAK,mBAAmB;AACxB,WAAK;AAAA;AAIT,UAAM,YAAY,KAAK;AACvB,QAAI,YAAY;AAChB,QAAI;AACJ,eAAW,QAAQ,OAAO;AACtB,UAAI,cAAc,UAAU,QAAQ;AAKhC,kBAAU,KAAM,WAAW,IAAI,UAAU,KAAK,QAAQ,iBAAiB,KAAK,QAAQ,iBAAiB,MAAM,KAAK;AAAA,aAE/G;AAED,mBAAW,UAAU;AAAA;AAEzB,eAAS,WAAW;AACpB;AAAA;AAEJ,QAAI,YAAY,UAAU,QAAQ;AAE9B,WAAK,QAAQ,YAAY,KAAK,SAAS,WAAW,aAAa;AAE/D,gBAAU,SAAS;AAAA;AAAA;AAAA,EAc3B,QAAQ,QAAQ,KAAK,KAAK,aAAa,aAAa,MAAM;AACtD,QAAI;AACJ,IAAC,OAAK,KAAK,6BAA6B,QAAQ,QAAO,SAAS,SAAS,IAAG,KAAK,MAAM,OAAO,MAAM;AACpG,WAAO,SAAS,UAAU,KAAK,WAAW;AACtC,YAAM,IAAI,KAAK,OAAO;AACtB,WAAK,OAAO;AACZ,cAAQ;AAAA;AAAA;AAAA;AAIpB,0BAAoB;AAAA,EAChB,YAAY,SAAS,MAAM,SAAS,QAAQ,SAAS;AACjD,SAAK,OAAO;AAEZ,SAAK,mBAAmB;AAExB,SAAK,2BAA2B;AAEhC,SAAK,yBAAyB;AAC9B,SAAK,UAAU;AACf,SAAK,OAAO;AACZ,SAAK,WAAW;AAChB,SAAK,UAAU;AACf,QAAI,QAAQ,SAAS,KAAK,QAAQ,OAAO,MAAM,QAAQ,OAAO,IAAI;AAC9D,WAAK,mBAAmB,IAAI,MAAM,QAAQ,SAAS,GAAG,KAAK;AAC3D,WAAK,UAAU;AAAA,WAEd;AACD,WAAK,mBAAmB;AAAA;AAE5B,QAAI,6BAA6B;AAC7B,WAAK,aAAa;AAAA;AAAA;AAAA,MAGtB,UAAU;AACV,WAAO,KAAK,QAAQ;AAAA;AAAA,EAwBxB,WAAW,OAAO,kBAAkB,MAAM,YAAY,UAAU;AAC5D,UAAM,UAAU,KAAK;AAErB,QAAI,SAAS;AACb,QAAI,YAAY,QAAW;AAEvB,cAAQ,iBAAiB,MAAM,OAAO,iBAAiB;AACvD,eACI,CAAC,YAAY,UACR,UAAU,KAAK,oBAAoB,UAAU;AACtD,UAAI,QAAQ;AACR,aAAK,mBAAmB;AAAA;AAAA,WAG3B;AAED,YAAM,SAAS;AACf,cAAQ,QAAQ;AAChB,UAAI,GAAG;AACP,WAAK,IAAI,GAAG,IAAI,QAAQ,SAAS,GAAG,KAAK;AACrC,YAAI,iBAAiB,MAAM,OAAO,aAAa,IAAI,iBAAiB;AACpE,YAAI,MAAM,UAAU;AAEhB,cAAI,KAAK,iBAAiB;AAAA;AAE9B,kBAAW,UAAS,CAAC,YAAY,MAAM,MAAM,KAAK,iBAAiB;AACnE,YAAI,MAAM,SAAS;AACf,kBAAQ;AAAA,mBAEH,UAAU,SAAS;AACxB,mBAAU,OAAM,QAAQ,MAAM,SAAS,IAAI,MAAM,QAAQ,IAAI;AAAA;AAIjE,aAAK,iBAAiB,KAAK;AAAA;AAAA;AAGnC,QAAI,UAAU,CAAC,UAAU;AACrB,WAAK,aAAa;AAAA;AAAA;AAAA,EAI1B,aAAa,OAAO;AAChB,QAAI,UAAU,SAAS;AACnB,WAAK,KAAK,SAAS,gBAAgB,KAAK;AAAA,WAEvC;AACD,UAAI,6BAA6B;AAC7B,YAAI,KAAK,eAAe,QAAW;AAC/B,eAAK,aAAa,yBAAyB,KAAK,SAAS,KAAK,MAAM;AAAA;AAExE,gBAAQ,KAAK,WAAW,UAAU,QAAQ,UAAU,SAAS,QAAQ;AAAA;AAEzE,WAAK,KAAK,SAAS,aAAa,KAAK,MAAO,UAAU,QAAQ,UAAU,SAAS,QAAQ;AAAA;AAAA;AAAA;AAIrG,iCAA2B,cAAc;AAAA,EACrC,cAAc;AACV,UAAM,GAAG;AACT,SAAK,OAAO;AAAA;AAAA,EAGhB,aAAa,OAAO;AAChB,QAAI,6BAA6B;AAC7B,UAAI,KAAK,eAAe,QAAW;AAC/B,aAAK,aAAa,yBAAyB,KAAK,SAAS,KAAK,MAAM;AAAA;AAExE,cAAQ,KAAK,WAAW;AAAA;AAG5B,SAAK,QAAQ,KAAK,QAAQ,UAAU,UAAU,SAAY;AAAA;AAAA;AAGlE,yCAAmC,cAAc;AAAA,EAC7C,cAAc;AACV,UAAM,GAAG;AACT,SAAK,OAAO;AAAA;AAAA,EAGhB,aAAa,OAAO;AAChB,QAAI,SAAS,UAAU,SAAS;AAC5B,WAAK,KAAK,SAAS,aAAa,KAAK,MAAM;AAAA,WAE1C;AACD,WAAK,KAAK,SAAS,gBAAgB,KAAK;AAAA;AAAA;AAAA;AAIpD,8BAAwB,cAAc;AAAA,EAClC,cAAc;AACV,UAAM,GAAG;AACT,SAAK,OAAO;AAAA;AAAA,EAKhB,WAAW,aAAa,kBAAkB,MAAM;AAC5C,QAAI;AACJ,kBAAe,OAAK,iBAAiB,MAAM,aAAa,iBAAiB,QAAQ,QAAQ,QAAO,SAAS,MAAK;AAC9G,QAAI,gBAAgB,UAAU;AAC1B;AAAA;AAEJ,UAAM,cAAc,KAAK;AAGzB,UAAM,uBAAwB,gBAAgB,WAAW,gBAAgB,WACrE,YAAY,YACR,YAAY,WAChB,YAAY,SACR,YAAY,QAChB,YAAY,YACR,YAAY;AAGpB,UAAM,oBAAoB,gBAAgB,WACrC,iBAAgB,WAAW;AAChC,QAAI,sBAAsB;AACtB,WAAK,QAAQ,oBAAoB,KAAK,MAAM,MAAM;AAAA;AAEtD,QAAI,mBAAmB;AAInB,WAAK,QAAQ,iBAAiB,KAAK,MAAM,MAAM;AAAA;AAEnD,SAAK,mBAAmB;AAAA;AAAA,EAE5B,YAAY,OAAO;AACf,QAAI,KAAI;AACR,QAAI,OAAO,KAAK,qBAAqB,YAAY;AAG7C,WAAK,iBAAiB,KAAM,OAAM,OAAK,KAAK,aAAa,QAAQ,QAAO,SAAS,SAAS,IAAG,UAAU,QAAQ,QAAO,SAAS,MAAK,KAAK,SAAS;AAAA,WAEjJ;AACD,WAAK,iBAAiB,YAAY;AAAA;AAAA;AAAA;AAI9C,wBAAkB;AAAA,EACd,YAAY,SAAS,QAAQ,SAAS;AAClC,SAAK,UAAU;AACf,SAAK,OAAO;AAEZ,SAAK,2BAA2B;AAEhC,SAAK,yBAAyB;AAC9B,SAAK,WAAW;AAChB,SAAK,UAAU;AAAA;AAAA,EAEnB,WAAW,OAAO;AACd,qBAAiB,MAAM;AAAA;AAAA;AAqBxB,IAAM,UAAK;AAAA,EAEd,uBAAuB;AAAA,EACvB,SAAS;AAAA,EACT,cAAc;AAAA,EACd,cAAc;AAAA,EACd,kBAAkB;AAAA,EAElB,mBAAmB;AAAA,EACnB,aAAa;AAAA,EACb,mBAAmB;AAAA,EAEnB,YAAY;AAAA,EACZ,gBAAgB;AAAA,EAChB,uBAAuB;AAAA,EACvB,YAAY;AAAA,EACZ,eAAe;AAAA,EACf,cAAc;AAAA;AAIlB,AAAC,MAAM,MAAK,YAAY,+BAA+B,QAAQ,OAAO,SAAS,SAAS,GAAG,KAAK,IAAI,UAAU;AAK9G,AAAE,OAAM,MAAK,YAAY,wBAAwB,QAAQ,OAAO,SAAS,KAAM,GAAG,qBAAqB,IAAK,KAAK;",
  "names": []
}

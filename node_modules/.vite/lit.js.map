{
  "version": 3,
  "sources": ["../../.yarn/cache/@lit-reactive-element-npm-1.0.0-rc.2-bb65b71e5a-9262c29596.zip/node_modules/@lit/reactive-element/development/css-tag.js", "../../.yarn/cache/@lit-reactive-element-npm-1.0.0-rc.2-bb65b71e5a-9262c29596.zip/node_modules/@lit/reactive-element/development/reactive-element.js", "../../.yarn/cache/lit-html-npm-2.0.0-rc.3-bb75de0211-828168d0b2.zip/node_modules/lit-html/development/lit-html.js", "../../.yarn/cache/lit-element-npm-3.0.0-rc.2-8e3ea20bf3-02b322b1dc.zip/node_modules/lit-element/development/lit-element.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n/**\n * Whether the current browser supports `adoptedStyleSheets`.\n */\nexport const supportsAdoptingStyleSheets = window.ShadowRoot &&\n    (window.ShadyCSS === undefined || window.ShadyCSS.nativeShadow) &&\n    'adoptedStyleSheets' in Document.prototype &&\n    'replace' in CSSStyleSheet.prototype;\nconst constructionToken = Symbol();\nexport class CSSResult {\n    constructor(cssText, safeToken) {\n        if (safeToken !== constructionToken) {\n            throw new Error('CSSResult is not constructable. Use `unsafeCSS` or `css` instead.');\n        }\n        this.cssText = cssText;\n    }\n    // Note, this is a getter so that it's lazy. In practice, this means\n    // stylesheets are not created until the first element instance is made.\n    get styleSheet() {\n        // Note, if `supportsAdoptingStyleSheets` is true then we assume\n        // CSSStyleSheet is constructable.\n        if (supportsAdoptingStyleSheets && this._styleSheet === undefined) {\n            this._styleSheet = new CSSStyleSheet();\n            this._styleSheet.replaceSync(this.cssText);\n        }\n        return this._styleSheet;\n    }\n    toString() {\n        return this.cssText;\n    }\n}\nconst cssResultCache = new Map();\nconst getCSSResult = (cssText) => {\n    let result = cssResultCache.get(cssText);\n    if (result === undefined) {\n        cssResultCache.set(cssText, (result = new CSSResult(cssText, constructionToken)));\n    }\n    return result;\n};\nconst textFromCSSResult = (value) => {\n    if (value instanceof CSSResult) {\n        return value.cssText;\n    }\n    else if (typeof value === 'number') {\n        return value;\n    }\n    else {\n        throw new Error(`Value passed to 'css' function must be a 'css' function result: ` +\n            `${value}. Use 'unsafeCSS' to pass non-literal values, but take care ` +\n            `to ensure page security.`);\n    }\n};\n/**\n * Wrap a value for interpolation in a [[`css`]] tagged template literal.\n *\n * This is unsafe because untrusted CSS text can be used to phone home\n * or exfiltrate data to an attacker controlled site. Take care to only use\n * this with trusted input.\n */\nexport const unsafeCSS = (value) => {\n    return getCSSResult(typeof value === 'string' ? value : String(value));\n};\n/**\n * Template tag which which can be used with LitElement's [[LitElement.styles |\n * `styles`]] property to set element styles. For security reasons, only literal\n * string values may be used. To incorporate non-literal values [[`unsafeCSS`]]\n * may be used inside a template string part.\n */\nexport const css = (strings, ...values) => {\n    const cssText = strings.length === 1\n        ? strings[0]\n        : values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);\n    return getCSSResult(cssText);\n};\n/**\n * Applies the given styles to a `shadowRoot`. When Shadow DOM is\n * available but `adoptedStyleSheets` is not, styles are appended to the\n * `shadowRoot` to [mimic spec behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).\n * Note, when shimming is used, any styles that are subsequently placed into\n * the shadowRoot should be placed *before* any shimmed adopted styles. This\n * will match spec behavior that gives adopted sheets precedence over styles in\n * shadowRoot.\n */\nexport const adoptStyles = (renderRoot, styles) => {\n    if (supportsAdoptingStyleSheets) {\n        renderRoot.adoptedStyleSheets = styles.map((s) => s instanceof CSSStyleSheet ? s : s.styleSheet);\n    }\n    else {\n        styles.forEach((s) => {\n            const style = document.createElement('style');\n            style.textContent = s.cssText;\n            renderRoot.appendChild(style);\n        });\n    }\n};\nconst cssResultFromStyleSheet = (sheet) => {\n    let cssText = '';\n    for (const rule of sheet.cssRules) {\n        cssText += rule.cssText;\n    }\n    return unsafeCSS(cssText);\n};\nexport const getCompatibleStyle = supportsAdoptingStyleSheets\n    ? (s) => s\n    : (s) => s instanceof CSSStyleSheet ? cssResultFromStyleSheet(s) : s;\n//# sourceMappingURL=css-tag.js.map", "/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nvar _a, _b, _c, _d;\nvar _e;\nvar _f;\n/**\n * Use this module if you want to create your own base class extending\n * [[ReactiveElement]].\n * @packageDocumentation\n */\nimport { getCompatibleStyle, adoptStyles, } from './css-tag.js';\nexport * from './css-tag.js';\nconst DEV_MODE = true;\nlet requestUpdateThenable;\nif (DEV_MODE) {\n    // TODO(sorvell): Add a link to the docs about using dev v. production mode.\n    console.warn(`Running in dev mode. Do not use in production!`);\n    // Issue platform support warning.\n    if (((_a = window.ShadyDOM) === null || _a === void 0 ? void 0 : _a.inUse) &&\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        globalThis['reactiveElementPlatformSupport'] === undefined) {\n        console.warn(`Shadow DOM is being polyfilled via ShadyDOM but ` +\n            `the \\`polyfill-support\\` module has not been loaded.`);\n    }\n    requestUpdateThenable = {\n        then: (onfulfilled, _onrejected) => {\n            console.warn(`\\`requestUpdate\\` no longer returns a Promise.` +\n                `Use \\`updateComplete\\` instead.`);\n            if (onfulfilled !== undefined) {\n                onfulfilled(false);\n            }\n        },\n    };\n}\n/*\n * When using Closure Compiler, JSCompiler_renameProperty(property, object) is\n * replaced at compile time by the munged name for object[property]. We cannot\n * alias this function, so we have to use a small shim that has the same\n * behavior when not compiling.\n */\n/*@__INLINE__*/\nconst JSCompiler_renameProperty = (prop, _obj) => prop;\nexport const defaultConverter = {\n    toAttribute(value, type) {\n        switch (type) {\n            case Boolean:\n                value = value ? '' : null;\n                break;\n            case Object:\n            case Array:\n                // if the value is `null` or `undefined` pass this through\n                // to allow removing/no change behavior.\n                value = value == null ? value : JSON.stringify(value);\n                break;\n        }\n        return value;\n    },\n    fromAttribute(value, type) {\n        let fromValue = value;\n        switch (type) {\n            case Boolean:\n                fromValue = value !== null;\n                break;\n            case Number:\n                fromValue = value === null ? null : Number(value);\n                break;\n            case Object:\n            case Array:\n                // Do *not* generate exception when invalid JSON is set as elements\n                // don't normally complain on being mis-configured.\n                // TODO(sorvell): Do generate exception in *dev mode*.\n                try {\n                    // Assert to adhere to Bazel's \"must type assert JSON parse\" rule.\n                    fromValue = JSON.parse(value);\n                }\n                catch (e) {\n                    fromValue = null;\n                }\n                break;\n        }\n        return fromValue;\n    },\n};\n/**\n * Change function that returns true if `value` is different from `oldValue`.\n * This method is used as the default for a property's `hasChanged` function.\n */\nexport const notEqual = (value, old) => {\n    // This ensures (old==NaN, value==NaN) always returns false\n    return old !== value && (old === old || value === value);\n};\nconst defaultPropertyDeclaration = {\n    attribute: true,\n    type: String,\n    converter: defaultConverter,\n    reflect: false,\n    hasChanged: notEqual,\n};\n/**\n * The Closure JS Compiler doesn't currently have good support for static\n * property semantics where \"this\" is dynamic (e.g.\n * https://github.com/google/closure-compiler/issues/3177 and others) so we use\n * this hack to bypass any rewriting by the compiler.\n */\nconst finalized = 'finalized';\n/**\n * Base element class which manages element properties and attributes. When\n * properties change, the `update` method is asynchronously called. This method\n * should be supplied by subclassers to render updates as desired.\n * @noInheritDoc\n */\nexport class ReactiveElement extends HTMLElement {\n    constructor() {\n        super();\n        this.__instanceProperties = new Map();\n        this.__pendingConnectionPromise = undefined;\n        this.__enableConnection = undefined;\n        /**\n         * @category updates\n         */\n        this.isUpdatePending = false;\n        /**\n         * @category updates\n         */\n        this.hasUpdated = false;\n        /**\n         * Name of currently reflecting property\n         */\n        this.__reflectingProperty = null;\n        this._initialize();\n    }\n    /**\n     * @nocollapse\n     */\n    static addInitializer(initializer) {\n        var _a;\n        (_a = this._initializers) !== null && _a !== void 0 ? _a : (this._initializers = []);\n        this._initializers.push(initializer);\n    }\n    /**\n     * Returns a list of attributes corresponding to the registered properties.\n     * @nocollapse\n     * @category attributes\n     */\n    static get observedAttributes() {\n        // note: piggy backing on this to ensure we're finalized.\n        this.finalize();\n        const attributes = [];\n        // Use forEach so this works even if for/of loops are compiled to for loops\n        // expecting arrays\n        this.elementProperties.forEach((v, p) => {\n            const attr = this.__attributeNameForProperty(p, v);\n            if (attr !== undefined) {\n                this.__attributeToPropertyMap.set(attr, p);\n                attributes.push(attr);\n            }\n        });\n        return attributes;\n    }\n    /**\n     * Creates a property accessor on the element prototype if one does not exist\n     * and stores a PropertyDeclaration for the property with the given options.\n     * The property setter calls the property's `hasChanged` property option\n     * or uses a strict identity check to determine whether or not to request\n     * an update.\n     *\n     * This method may be overridden to customize properties; however,\n     * when doing so, it's important to call `super.createProperty` to ensure\n     * the property is setup correctly. This method calls\n     * `getPropertyDescriptor` internally to get a descriptor to install.\n     * To customize what properties do when they are get or set, override\n     * `getPropertyDescriptor`. To customize the options for a property,\n     * implement `createProperty` like this:\n     *\n     * static createProperty(name, options) {\n     *   options = Object.assign(options, {myOption: true});\n     *   super.createProperty(name, options);\n     * }\n     *\n     * @nocollapse\n     * @category properties\n     */\n    static createProperty(name, options = defaultPropertyDeclaration) {\n        // if this is a state property, force the attribute to false.\n        if (options.state) {\n            // Cast as any since this is readonly.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            options.attribute = false;\n        }\n        // Note, since this can be called by the `@property` decorator which\n        // is called before `finalize`, we ensure finalization has been kicked off.\n        this.finalize();\n        this.elementProperties.set(name, options);\n        // Do not generate an accessor if the prototype already has one, since\n        // it would be lost otherwise and that would never be the user's intention;\n        // Instead, we expect users to call `requestUpdate` themselves from\n        // user-defined accessors. Note that if the super has an accessor we will\n        // still overwrite it\n        if (!options.noAccessor && !this.prototype.hasOwnProperty(name)) {\n            const key = typeof name === 'symbol' ? Symbol() : `__${name}`;\n            const descriptor = this.getPropertyDescriptor(name, key, options);\n            if (descriptor !== undefined) {\n                Object.defineProperty(this.prototype, name, descriptor);\n            }\n        }\n    }\n    /**\n     * Returns a property descriptor to be defined on the given named property.\n     * If no descriptor is returned, the property will not become an accessor.\n     * For example,\n     *\n     *   class MyElement extends LitElement {\n     *     static getPropertyDescriptor(name, key, options) {\n     *       const defaultDescriptor =\n     *           super.getPropertyDescriptor(name, key, options);\n     *       const setter = defaultDescriptor.set;\n     *       return {\n     *         get: defaultDescriptor.get,\n     *         set(value) {\n     *           setter.call(this, value);\n     *           // custom action.\n     *         },\n     *         configurable: true,\n     *         enumerable: true\n     *       }\n     *     }\n     *   }\n     *\n     * @nocollapse\n     * @category properties\n     */\n    static getPropertyDescriptor(name, key, options) {\n        return {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            get() {\n                return this[key];\n            },\n            set(value) {\n                const oldValue = this[name];\n                this[key] = value;\n                this.requestUpdate(name, oldValue, options);\n            },\n            configurable: true,\n            enumerable: true,\n        };\n    }\n    /**\n     * Returns the property options associated with the given property.\n     * These options are defined with a PropertyDeclaration via the `properties`\n     * object or the `@property` decorator and are registered in\n     * `createProperty(...)`.\n     *\n     * Note, this method should be considered \"final\" and not overridden. To\n     * customize the options for a given property, override `createProperty`.\n     *\n     * @nocollapse\n     * @final\n     * @category properties\n     */\n    static getPropertyOptions(name) {\n        return this.elementProperties.get(name) || defaultPropertyDeclaration;\n    }\n    /**\n     * Creates property accessors for registered properties, sets up element\n     * styling, and ensures any superclasses are also finalized. Returns true if\n     * the element was finalized.\n     * @nocollapse\n     */\n    static finalize() {\n        if (this.hasOwnProperty(finalized)) {\n            return false;\n        }\n        this[finalized] = true;\n        // finalize any superclasses\n        const superCtor = Object.getPrototypeOf(this);\n        superCtor.finalize();\n        this.elementProperties = new Map(superCtor.elementProperties);\n        // initialize Map populated in observedAttributes\n        this.__attributeToPropertyMap = new Map();\n        // make any properties\n        // Note, only process \"own\" properties since this element will inherit\n        // any properties defined on the superClass, and finalization ensures\n        // the entire prototype chain is finalized.\n        if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {\n            const props = this.properties;\n            // support symbols in properties (IE11 does not support this)\n            const propKeys = [\n                ...Object.getOwnPropertyNames(props),\n                ...Object.getOwnPropertySymbols(props),\n            ];\n            // This for/of is ok because propKeys is an array\n            for (const p of propKeys) {\n                // note, use of `any` is due to TypeScript lack of support for symbol in\n                // index types\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                this.createProperty(p, props[p]);\n            }\n        }\n        this.elementStyles = this.finalizeStyles(this.styles);\n        // DEV mode warnings\n        if (DEV_MODE) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const warnRemoved = (obj, name) => {\n                if (obj[name] !== undefined) {\n                    console.warn(`\\`${name}\\` is implemented. It ` +\n                        `has been removed from this version of ReactiveElement.` +\n                        ` See the changelog at https://github.com/lit/lit/blob/main/packages/reactive-element/CHANGELOG.md`);\n                }\n            };\n            [`initialize`, `requestUpdateInternal`, `_getUpdateComplete`].forEach((name) => \n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            warnRemoved(this.prototype, name));\n        }\n        return true;\n    }\n    /**\n     * Takes the styles the user supplied via the `static styles` property and\n     * returns the array of styles to apply to the element.\n     * Override this method to integrate into a style management system.\n     *\n     * Styles are deduplicated preserving the _last_ instance in the list. This\n     * is a performance optimization to avoid duplicated styles that can occur\n     * especially when composing via subclassing. The last item is kept to try\n     * to preserve the cascade order with the assumption that it's most important\n     * that last added styles override previous styles.\n     *\n     * @nocollapse\n     * @category styles\n     */\n    static finalizeStyles(styles) {\n        const elementStyles = [];\n        if (Array.isArray(styles)) {\n            // Dedupe the flattened array in reverse order to preserve the last items.\n            // TODO(sorvell): casting to Array<unknown> works around TS error that\n            // appears to come from trying to flatten a type CSSResultArray.\n            const set = new Set(styles.flat(Infinity).reverse());\n            // Then preserve original order by adding the set items in reverse order.\n            for (const s of set) {\n                elementStyles.unshift(getCompatibleStyle(s));\n            }\n        }\n        else if (styles !== undefined) {\n            elementStyles.push(getCompatibleStyle(styles));\n        }\n        return elementStyles;\n    }\n    /**\n     * Returns the property name for the given attribute `name`.\n     * @nocollapse\n     */\n    static __attributeNameForProperty(name, options) {\n        const attribute = options.attribute;\n        return attribute === false\n            ? undefined\n            : typeof attribute === 'string'\n                ? attribute\n                : typeof name === 'string'\n                    ? name.toLowerCase()\n                    : undefined;\n    }\n    /**\n     * Internal only override point for customizing work done when elements\n     * are constructed.\n     *\n     * @internal\n     */\n    _initialize() {\n        var _a;\n        this.__updatePromise = new Promise((res) => (this.enableUpdating = res));\n        this._$changedProperties = new Map();\n        this.__saveInstanceProperties();\n        // ensures first update will be caught by an early access of\n        // `updateComplete`\n        this.requestUpdate();\n        (_a = this.constructor._initializers) === null || _a === void 0 ? void 0 : _a.forEach((i) => i(this));\n    }\n    /**\n     * @category controllers\n     */\n    addController(controller) {\n        var _a, _b;\n        ((_a = this.__controllers) !== null && _a !== void 0 ? _a : (this.__controllers = [])).push(controller);\n        // If a controller is added after the element has been connected,\n        // call hostConnected. Note, re-using existence of `renderRoot` here\n        // (which is set in connectedCallback) to avoid the need to track a\n        // first connected state.\n        if (this.renderRoot !== undefined && this.isConnected) {\n            (_b = controller.hostConnected) === null || _b === void 0 ? void 0 : _b.call(controller);\n        }\n    }\n    /**\n     * @category controllers\n     */\n    removeController(controller) {\n        var _a;\n        // Note, if the indexOf is -1, the >>> will flip the sign which makes the\n        // splice do nothing.\n        (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.splice(this.__controllers.indexOf(controller) >>> 0, 1);\n    }\n    /**\n     * Fixes any properties set on the instance before upgrade time.\n     * Otherwise these would shadow the accessor and break these properties.\n     * The properties are stored in a Map which is played back after the\n     * constructor runs. Note, on very old versions of Safari (<=9) or Chrome\n     * (<=41), properties created for native platform properties like (`id` or\n     * `name`) may not have default values set in the element constructor. On\n     * these browsers native properties appear on instances and therefore their\n     * default value will overwrite any element default (e.g. if the element sets\n     * this.id = 'id' in the constructor, the 'id' will become '' since this is\n     * the native platform default).\n     */\n    __saveInstanceProperties() {\n        // Use forEach so this works even if for/of loops are compiled to for loops\n        // expecting arrays\n        this.constructor.elementProperties.forEach((_v, p) => {\n            if (this.hasOwnProperty(p)) {\n                this.__instanceProperties.set(p, this[p]);\n                delete this[p];\n            }\n        });\n    }\n    /**\n     * Returns the node into which the element should render and by default\n     * creates and returns an open shadowRoot. Implement to customize where the\n     * element's DOM is rendered. For example, to render into the element's\n     * childNodes, return `this`.\n     *\n     * @return Returns a node into which to render.\n     * @category rendering\n     */\n    createRenderRoot() {\n        var _a;\n        const renderRoot = (_a = this.shadowRoot) !== null && _a !== void 0 ? _a : this.attachShadow(this.constructor.shadowRootOptions);\n        adoptStyles(renderRoot, this.constructor.elementStyles);\n        return renderRoot;\n    }\n    /**\n     * On first connection, creates the element's renderRoot, sets up\n     * element styling, and enables updating.\n     * @category lifecycle\n     */\n    connectedCallback() {\n        var _a;\n        // create renderRoot before first update.\n        if (this.renderRoot === undefined) {\n            this.renderRoot = this.createRenderRoot();\n        }\n        this.enableUpdating(true);\n        (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.forEach((c) => { var _a; return (_a = c.hostConnected) === null || _a === void 0 ? void 0 : _a.call(c); });\n        // If we were disconnected, re-enable updating by resolving the pending\n        // connection promise\n        if (this.__enableConnection) {\n            this.__enableConnection();\n            this.__pendingConnectionPromise = this.__enableConnection = undefined;\n        }\n    }\n    /**\n     * Note, this method should be considered final and not overridden. It is\n     * overridden on the element instance with a function that triggers the first\n     * update.\n     * @category updates\n     */\n    enableUpdating(_requestedUpdate) { }\n    /**\n     * Allows for `super.disconnectedCallback()` in extensions while\n     * reserving the possibility of making non-breaking feature additions\n     * when disconnecting at some point in the future.\n     * @category lifecycle\n     */\n    disconnectedCallback() {\n        var _a;\n        (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.forEach((c) => { var _a; return (_a = c.hostDisconnected) === null || _a === void 0 ? void 0 : _a.call(c); });\n        this.__pendingConnectionPromise = new Promise((r) => (this.__enableConnection = r));\n    }\n    /**\n     * Synchronizes property values when attributes change.\n     * @category attributes\n     */\n    attributeChangedCallback(name, _old, value) {\n        this._$attributeToProperty(name, value);\n    }\n    __propertyToAttribute(name, value, options = defaultPropertyDeclaration) {\n        var _a, _b;\n        const attr = this\n            .constructor.__attributeNameForProperty(name, options);\n        if (attr !== undefined && options.reflect === true) {\n            const toAttribute = (_b = (_a = options.converter) === null || _a === void 0 ? void 0 : _a.toAttribute) !== null && _b !== void 0 ? _b : defaultConverter.toAttribute;\n            const attrValue = toAttribute(value, options.type);\n            if (DEV_MODE &&\n                this.constructor.enabledWarnings.indexOf('migration') >= 0 &&\n                attrValue === undefined) {\n                console.warn(`The attribute value for the ` +\n                    `${name} property is undefined. The attribute will be ` +\n                    `removed, but in the previous version of ReactiveElement, the ` +\n                    `attribute would not have changed.`);\n            }\n            // Track if the property is being reflected to avoid\n            // setting the property again via `attributeChangedCallback`. Note:\n            // 1. this takes advantage of the fact that the callback is synchronous.\n            // 2. will behave incorrectly if multiple attributes are in the reaction\n            // stack at time of calling. However, since we process attributes\n            // in `update` this should not be possible (or an extreme corner case\n            // that we'd like to discover).\n            // mark state reflecting\n            this.__reflectingProperty = name;\n            if (attrValue == null) {\n                this.removeAttribute(attr);\n            }\n            else {\n                this.setAttribute(attr, attrValue);\n            }\n            // mark state not reflecting\n            this.__reflectingProperty = null;\n        }\n    }\n    /** @internal */\n    _$attributeToProperty(name, value) {\n        var _a, _b, _c;\n        const ctor = this.constructor;\n        // Note, hint this as an `AttributeMap` so closure clearly understands\n        // the type; it has issues with tracking types through statics\n        const propName = ctor.__attributeToPropertyMap.get(name);\n        // Use tracking info to avoid reflecting a property value to an attribute\n        // if it was just set because the attribute changed.\n        if (propName !== undefined && this.__reflectingProperty !== propName) {\n            const options = ctor.getPropertyOptions(propName);\n            const converter = options.converter;\n            const fromAttribute = (_c = (_b = (_a = converter) === null || _a === void 0 ? void 0 : _a.fromAttribute) !== null && _b !== void 0 ? _b : (typeof converter === 'function'\n                ? converter\n                : null)) !== null && _c !== void 0 ? _c : defaultConverter.fromAttribute;\n            // mark state reflecting\n            this.__reflectingProperty = propName;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this[propName] = fromAttribute(value, options.type);\n            // mark state not reflecting\n            this.__reflectingProperty = null;\n        }\n    }\n    /**\n     * Requests an update which is processed asynchronously. This should be called\n     * when an element should update based on some state not triggered by setting\n     * a reactive property. In this case, pass no arguments. It should also be\n     * called when manually implementing a property setter. In this case, pass the\n     * property `name` and `oldValue` to ensure that any configured property\n     * options are honored.\n     *\n     * @param name name of requesting property\n     * @param oldValue old value of requesting property\n     * @param options property options to use instead of the previously\n     *     configured options\n     * @category updates\n     */\n    requestUpdate(name, oldValue, options) {\n        let shouldRequestUpdate = true;\n        // If we have a property key, perform property update steps.\n        if (name !== undefined) {\n            options =\n                options ||\n                    this.constructor.getPropertyOptions(name);\n            const hasChanged = options.hasChanged || notEqual;\n            if (hasChanged(this[name], oldValue)) {\n                if (!this._$changedProperties.has(name)) {\n                    this._$changedProperties.set(name, oldValue);\n                }\n                // Add to reflecting properties set.\n                // Note, it's important that every change has a chance to add the\n                // property to `_reflectingProperties`. This ensures setting\n                // attribute + property reflects correctly.\n                if (options.reflect === true && this.__reflectingProperty !== name) {\n                    if (this.__reflectingProperties === undefined) {\n                        this.__reflectingProperties = new Map();\n                    }\n                    this.__reflectingProperties.set(name, options);\n                }\n            }\n            else {\n                // Abort the request if the property should not be considered changed.\n                shouldRequestUpdate = false;\n            }\n        }\n        if (!this.isUpdatePending && shouldRequestUpdate) {\n            this.__updatePromise = this.__enqueueUpdate();\n        }\n        // Note, since this no longer returns a promise, in dev mode we return a\n        // thenable which warns if it's called.\n        return DEV_MODE ? requestUpdateThenable : undefined;\n    }\n    /**\n     * Sets up the element to asynchronously update.\n     */\n    async __enqueueUpdate() {\n        this.isUpdatePending = true;\n        try {\n            // Ensure any previous update has resolved before updating.\n            // This `await` also ensures that property changes are batched.\n            await this.__updatePromise;\n            // If we were disconnected, wait until re-connected to flush an update\n            while (this.__pendingConnectionPromise) {\n                await this.__pendingConnectionPromise;\n            }\n        }\n        catch (e) {\n            // Refire any previous errors async so they do not disrupt the update\n            // cycle. Errors are refired so developers have a chance to observe\n            // them, and this can be done by implementing\n            // `window.onunhandledrejection`.\n            Promise.reject(e);\n        }\n        const result = this.performUpdate();\n        // If `performUpdate` returns a Promise, we await it. This is done to\n        // enable coordinating updates with a scheduler. Note, the result is\n        // checked to avoid delaying an additional microtask unless we need to.\n        if (result != null) {\n            await result;\n        }\n        return !this.isUpdatePending;\n    }\n    /**\n     * Performs an element update. Note, if an exception is thrown during the\n     * update, `firstUpdated` and `updated` will not be called.\n     *\n     * You can override this method to change the timing of updates. If this\n     * method is overridden, `super.performUpdate()` must be called.\n     *\n     * For instance, to schedule updates to occur just before the next frame:\n     *\n     * ```\n     * protected async performUpdate(): Promise<unknown> {\n     *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));\n     *   super.performUpdate();\n     * }\n     * ```\n     * @category updates\n     */\n    performUpdate() {\n        var _a;\n        // Abort any update if one is not pending when this is called.\n        // This can happen if `performUpdate` is called early to \"flush\"\n        // the update.\n        if (!this.isUpdatePending) {\n            return;\n        }\n        // create renderRoot before first update.\n        if (!this.hasUpdated) {\n            // Produce warning if any class properties are shadowed by class fields\n            if (DEV_MODE) {\n                const shadowedProperties = [];\n                this.constructor.elementProperties.forEach((_v, p) => {\n                    var _a;\n                    if (this.hasOwnProperty(p) && !((_a = this.__instanceProperties) === null || _a === void 0 ? void 0 : _a.has(p))) {\n                        shadowedProperties.push(p);\n                    }\n                });\n                if (shadowedProperties.length) {\n                    // TODO(sorvell): Link to docs explanation of this issue.\n                    console.warn(`The following properties will not trigger updates as expected ` +\n                        `because they are set using class fields: ` +\n                        `${shadowedProperties.join(', ')}. ` +\n                        `Native class fields and some compiled output will overwrite ` +\n                        `accessors used for detecting changes. To fix this issue, ` +\n                        `either initialize properties in the constructor or adjust ` +\n                        `your compiler settings; for example, for TypeScript set ` +\n                        `\\`useDefineForClassFields: false\\` in your \\`tsconfig.json\\`.`);\n                }\n            }\n        }\n        // Mixin instance properties once, if they exist.\n        if (this.__instanceProperties) {\n            // Use forEach so this works even if for/of loops are compiled to for loops\n            // expecting arrays\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.__instanceProperties.forEach((v, p) => (this[p] = v));\n            this.__instanceProperties = undefined;\n        }\n        let shouldUpdate = false;\n        const changedProperties = this._$changedProperties;\n        try {\n            shouldUpdate = this.shouldUpdate(changedProperties);\n            if (shouldUpdate) {\n                this.willUpdate(changedProperties);\n                (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.forEach((c) => { var _a; return (_a = c.hostUpdate) === null || _a === void 0 ? void 0 : _a.call(c); });\n                this.update(changedProperties);\n            }\n            else {\n                this.__markUpdated();\n            }\n        }\n        catch (e) {\n            // Prevent `firstUpdated` and `updated` from running when there's an\n            // update exception.\n            shouldUpdate = false;\n            // Ensure element can accept additional updates after an exception.\n            this.__markUpdated();\n            throw e;\n        }\n        // The update is no longer considered pending and further updates are now allowed.\n        if (shouldUpdate) {\n            this._$didUpdate(changedProperties);\n        }\n    }\n    /**\n     * @category updates\n     */\n    willUpdate(_changedProperties) { }\n    // Note, this is an override point for polyfill-support.\n    // @internal\n    _$didUpdate(changedProperties) {\n        var _a;\n        (_a = this.__controllers) === null || _a === void 0 ? void 0 : _a.forEach((c) => { var _a; return (_a = c.hostUpdated) === null || _a === void 0 ? void 0 : _a.call(c); });\n        if (!this.hasUpdated) {\n            this.hasUpdated = true;\n            this.firstUpdated(changedProperties);\n        }\n        this.updated(changedProperties);\n        if (DEV_MODE &&\n            this.isUpdatePending &&\n            this.constructor.enabledWarnings.indexOf('change-in-update') >= 0) {\n            console.warn(`An update was requested (generally because a property was set) ` +\n                `after an update completed, causing a new update to be scheduled. ` +\n                `This is inefficient and should be avoided unless the next update ` +\n                `can only be scheduled as a side effect of the previous update.`);\n        }\n    }\n    __markUpdated() {\n        this._$changedProperties = new Map();\n        this.isUpdatePending = false;\n    }\n    /**\n     * Returns a Promise that resolves when the element has completed updating.\n     * The Promise value is a boolean that is `true` if the element completed the\n     * update without triggering another update. The Promise result is `false` if\n     * a property was set inside `updated()`. If the Promise is rejected, an\n     * exception was thrown during the update.\n     *\n     * To await additional asynchronous work, override the `getUpdateComplete`\n     * method. For example, it is sometimes useful to await a rendered element\n     * before fulfilling this Promise. To do this, first await\n     * `super.getUpdateComplete()`, then any subsequent state.\n     *\n     * @return A promise of a boolean that indicates if the update resolved\n     *     without triggering another update.\n     * @category updates\n     */\n    get updateComplete() {\n        return this.getUpdateComplete();\n    }\n    /**\n     * Override point for the `updateComplete` promise.\n     *\n     * It is not safe to override the `updateComplete` getter directly due to a\n     * limitation in TypeScript which means it is not possible to call a\n     * superclass getter (e.g. `super.updateComplete.then(...)`) when the target\n     * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).\n     * This method should be overridden instead. For example:\n     *\n     *   class MyElement extends LitElement {\n     *     async getUpdateComplete() {\n     *       await super.getUpdateComplete();\n     *       await this._myChild.updateComplete;\n     *     }\n     *   }\n     * @category updates\n     */\n    getUpdateComplete() {\n        return this.__updatePromise;\n    }\n    /**\n     * Controls whether or not `update` should be called when the element requests\n     * an update. By default, this method always returns `true`, but this can be\n     * customized to control when to update.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     * @category updates\n     */\n    shouldUpdate(_changedProperties) {\n        return true;\n    }\n    /**\n     * Updates the element. This method reflects property values to attributes.\n     * It can be overridden to render and keep updated element DOM.\n     * Setting properties inside this method will *not* trigger\n     * another update.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     * @category updates\n     */\n    update(_changedProperties) {\n        if (this.__reflectingProperties !== undefined) {\n            // Use forEach so this works even if for/of loops are compiled to for\n            // loops expecting arrays\n            this.__reflectingProperties.forEach((v, k) => this.__propertyToAttribute(k, this[k], v));\n            this.__reflectingProperties = undefined;\n        }\n        this.__markUpdated();\n    }\n    /**\n     * Invoked whenever the element is updated. Implement to perform\n     * post-updating tasks via DOM APIs, for example, focusing an element.\n     *\n     * Setting properties inside this method will trigger the element to update\n     * again after this update cycle completes.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     * @category updates\n     */\n    updated(_changedProperties) { }\n    /**\n     * Invoked when the element is first updated. Implement to perform one time\n     * work on the element after update.\n     *\n     * Setting properties inside this method will trigger the element to update\n     * again after this update cycle completes.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     * @category updates\n     */\n    firstUpdated(_changedProperties) { }\n}\n_f = finalized;\n/**\n * Marks class as having finished creating properties.\n */\nReactiveElement[_f] = true;\n/**\n * Memoized list of all element properties, including any superclass properties.\n * Created lazily on user subclasses when finalizing the class.\n * @nocollapse\n * @category properties\n */\nReactiveElement.elementProperties = new Map();\n/**\n * Memoized list of all element styles.\n * Created lazily on user subclasses when finalizing the class.\n * @nocollapse\n * @category styles\n */\nReactiveElement.elementStyles = [];\n/**\n * Options used when calling `attachShadow`. Set this property to customize\n * the options for the shadowRoot; for example, to create a closed\n * shadowRoot: `{mode: 'closed'}`.\n *\n * Note, these options are used in `createRenderRoot`. If this method\n * is customized, options should be respected if possible.\n * @nocollapse\n * @category rendering\n */\nReactiveElement.shadowRootOptions = { mode: 'open' };\n// Apply polyfills if available\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(_c = (_b = globalThis)['reactiveElementPlatformSupport']) === null || _c === void 0 ? void 0 : _c.call(_b, { ReactiveElement });\n// Dev mode warnings...\nif (DEV_MODE) {\n    // Default warning set.\n    ReactiveElement.enabledWarnings = ['change-in-update'];\n    const ensureOwnWarnings = function (ctor) {\n        if (!ctor.hasOwnProperty(JSCompiler_renameProperty('enabledWarnings', ctor))) {\n            ctor.enabledWarnings = ctor.enabledWarnings.slice();\n        }\n    };\n    ReactiveElement.enableWarning = function (warning) {\n        ensureOwnWarnings(this);\n        if (this.enabledWarnings.indexOf(warning) < 0) {\n            this.enabledWarnings.push(warning);\n        }\n    };\n    ReactiveElement.disableWarning = function (warning) {\n        ensureOwnWarnings(this);\n        const i = this.enabledWarnings.indexOf(warning);\n        if (i >= 0) {\n            this.enabledWarnings.splice(i, 1);\n        }\n    };\n}\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for ReactiveElement usage.\n// TODO(justinfagnani): inject version number at build time\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n((_d = (_e = globalThis)['reactiveElementVersions']) !== null && _d !== void 0 ? _d : (_e['reactiveElementVersions'] = [])).push('1.0.0-rc.2');\n//# sourceMappingURL=reactive-element.js.map", "/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nvar _a, _b, _c, _d, _e;\nvar _f;\nconst DEV_MODE = true;\nconst ENABLE_EXTRA_SECURITY_HOOKS = true;\nconst ENABLE_SHADYDOM_NOPATCH = true;\nif (DEV_MODE) {\n    console.warn('lit-html is in dev mode. Not recommended for production!');\n}\nconst wrap = ENABLE_SHADYDOM_NOPATCH && ((_a = window.ShadyDOM) === null || _a === void 0 ? void 0 : _a.inUse) &&\n    ((_b = window.ShadyDOM) === null || _b === void 0 ? void 0 : _b.noPatch) === true\n    ? window.ShadyDOM.wrap\n    : (node) => node;\nconst trustedTypes = globalThis.trustedTypes;\n/**\n * Our TrustedTypePolicy for HTML which is declared using the html template\n * tag function.\n *\n * That HTML is a developer-authored constant, and is parsed with innerHTML\n * before any untrusted expressions have been mixed in. Therefor it is\n * considered safe by construction.\n */\nconst policy = trustedTypes\n    ? trustedTypes.createPolicy('lit-html', {\n        createHTML: (s) => s,\n    })\n    : undefined;\nconst identityFunction = (value) => value;\nconst noopSanitizer = (_node, _name, _type) => identityFunction;\n/** Sets the global sanitizer factory. */\nconst setSanitizer = (newSanitizer) => {\n    if (!ENABLE_EXTRA_SECURITY_HOOKS) {\n        return;\n    }\n    if (sanitizerFactoryInternal !== noopSanitizer) {\n        throw new Error(`Attempted to overwrite existing lit-html security policy.` +\n            ` setSanitizeDOMValueFactory should be called at most once.`);\n    }\n    sanitizerFactoryInternal = newSanitizer;\n};\n/**\n * Only used in internal tests, not a part of the public API.\n */\nconst _testOnlyClearSanitizerFactoryDoNotCallOrElse = () => {\n    sanitizerFactoryInternal = noopSanitizer;\n};\nconst createSanitizer = (node, name, type) => {\n    return sanitizerFactoryInternal(node, name, type);\n};\n// Added to an attribute name to mark the attribute as bound so we can find\n// it easily.\nconst boundAttributeSuffix = '$lit$';\n// This marker is used in many syntactic positions in HTML, so it must be\n// a valid element name and attribute name. We don't support dynamic names (yet)\n// but this at least ensures that the parse tree is closer to the template\n// intention.\nconst marker = `lit$${String(Math.random()).slice(9)}$`;\n// String used to tell if a comment is a marker comment\nconst markerMatch = '?' + marker;\n// Text used to insert a comment marker node. We use processing instruction\n// syntax because it's slightly smaller, but parses as a comment node.\nconst nodeMarker = `<${markerMatch}>`;\nconst d = document;\n// Creates a dynamic marker. We never have to search for these in the DOM.\nconst createMarker = (v = '') => d.createComment(v);\nconst isPrimitive = (value) => value === null || (typeof value != 'object' && typeof value != 'function');\nconst isArray = Array.isArray;\nconst isIterable = (value) => {\n    var _a;\n    return isArray(value) ||\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        typeof ((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.iterator]) === 'function';\n};\nconst SPACE_CHAR = `[ \\t\\n\\f\\r]`;\nconst ATTR_VALUE_CHAR = `[^ \\t\\n\\f\\r\"'\\`<>=]`;\nconst NAME_CHAR = `[^\\\\s\"'>=/]`;\n// These regexes represent the five parsing states that we care about in the\n// Template's HTML scanner. They match the *end* of the state they're named\n// after.\n// Depending on the match, we transition to a new state. If there's no match,\n// we stay in the same state.\n// Note that the regexes are stateful. We utilize lastIndex and sync it\n// across the multiple regexes used. In addition to the five regexes below\n// we also dynamically create a regex to find the matching end tags for raw\n// text elements.\n/**\n * End of text is: `<` followed by:\n *   (comment start) or (tag) or (dynamic tag binding)\n */\nconst textEndRegex = /<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g;\nconst COMMENT_START = 1;\nconst TAG_NAME = 2;\nconst DYNAMIC_TAG_NAME = 3;\nconst commentEndRegex = /-->/g;\n/**\n * Comments not started with <!--, like </{, can be ended by a single `>`\n */\nconst comment2EndRegex = />/g;\n/**\n * The tagEnd regex matches the end of the \"inside an opening\" tag syntax\n * position. It either matches a `>`, an attribute-like sequence, or the end\n * of the string after a space (attribute-name position ending).\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\n *\n * \" \\t\\n\\f\\r\" are HTML space characters:\n * https://infra.spec.whatwg.org/#ascii-whitespace\n *\n * So an attribute is:\n *  * The name: any character except a whitespace character, (\"), ('), \">\",\n *    \"=\", or \"/\". Note: this is different from the HTML spec which also excludes control characters.\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nconst tagEndRegex = new RegExp(`>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|(\"|')|))|$)`, 'g');\nconst ENTIRE_MATCH = 0;\nconst ATTRIBUTE_NAME = 1;\nconst SPACES_AND_EQUALS = 2;\nconst QUOTE_CHAR = 3;\nconst singleQuoteAttrEndRegex = /'/g;\nconst doubleQuoteAttrEndRegex = /\"/g;\n/**\n * Matches the raw text elements.\n *\n * Comments are not parsed within raw text elements, so we need to search their\n * text content for marker strings.\n */\nconst rawTextElement = /^(?:script|style|textarea)$/i;\n/** TemplateResult types */\nconst HTML_RESULT = 1;\nconst SVG_RESULT = 2;\n// TemplatePart types\n// IMPORTANT: these must match the values in PartType\nconst ATTRIBUTE_PART = 1;\nconst CHILD_PART = 2;\nconst PROPERTY_PART = 3;\nconst BOOLEAN_ATTRIBUTE_PART = 4;\nconst EVENT_PART = 5;\nconst ELEMENT_PART = 6;\nconst COMMENT_PART = 7;\n/**\n * Generates a template literal tag function that returns a TemplateResult with\n * the given result type.\n */\nconst tag = (_$litType$) => (strings, ...values) => ({\n    _$litType$,\n    strings,\n    values,\n});\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = tag(HTML_RESULT);\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = tag(SVG_RESULT);\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nexport const noChange = Symbol.for('lit-noChange');\n/**\n * A sentinel value that signals a ChildPart to fully clear its content.\n */\nexport const nothing = Symbol.for('lit-nothing');\n/**\n * The cache of prepared templates, keyed by the tagged TemplateStringsArray\n * and _not_ accounting for the specific template tag used. This means that\n * template tags cannot be dynamic - the must statically be one of html, svg,\n * or attr. This restriction simplifies the cache lookup, which is on the hot\n * path for rendering.\n */\nconst templateCache = new WeakMap();\n/**\n * Renders a value, usually a lit-html TemplateResult, to the container.\n * @param value\n * @param container\n * @param options\n */\nexport const render = (value, container, options) => {\n    var _a, _b;\n    const partOwnerNode = (_a = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _a !== void 0 ? _a : container;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let part = partOwnerNode._$litPart$;\n    if (part === undefined) {\n        const endNode = (_b = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _b !== void 0 ? _b : null;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        partOwnerNode._$litPart$ = part = new ChildPart(container.insertBefore(createMarker(), endNode), endNode, undefined, options);\n    }\n    part._$setValue(value);\n    return part;\n};\nif (ENABLE_EXTRA_SECURITY_HOOKS) {\n    render.setSanitizer = setSanitizer;\n    render.createSanitizer = createSanitizer;\n    if (DEV_MODE) {\n        render._testOnlyClearSanitizerFactoryDoNotCallOrElse = _testOnlyClearSanitizerFactoryDoNotCallOrElse;\n    }\n}\nconst walker = d.createTreeWalker(d, 129 /* NodeFilter.SHOW_{ELEMENT|COMMENT} */, null, false);\nlet sanitizerFactoryInternal = noopSanitizer;\n/**\n * Returns an HTML string for the given TemplateStringsArray and result type\n * (HTML or SVG), along with the case-sensitive bound attribute names in\n * template order. The HTML contains comment comment markers denoting the\n * `ChildPart`s and suffixes on bound attributes denoting the `AttributeParts`.\n *\n * @param strings template strings array\n * @param type HTML or SVG\n * @return Array containing `[html, attrNames]` (array returned for terseness,\n *     to avoid object fields since this code is shared with non-minified SSR\n *     code)\n */\nconst getTemplateHtml = (strings, type) => {\n    // Insert makers into the template HTML to represent the position of\n    // bindings. The following code scans the template strings to determine the\n    // syntactic position of the bindings. They can be in text position, where\n    // we insert an HTML comment, attribute value position, where we insert a\n    // sentinel string and re-write the attribute name, or inside a tag where\n    // we insert the sentinel string.\n    const l = strings.length - 1;\n    // Stores the case-sensitive bound attribute names in the order of their\n    // parts. ElementParts are also reflected in this array as undefined\n    // rather than a string, to disambiguate from attribute bindings.\n    const attrNames = [];\n    let html = type === SVG_RESULT ? '<svg>' : '';\n    // When we're inside a raw text tag (not it's text content), the regex\n    // will still be tagRegex so we can find attributes, but will switch to\n    // this regex when the tag ends.\n    let rawTextEndRegex;\n    // The current parsing state, represented as a reference to one of the\n    // regexes\n    let regex = textEndRegex;\n    for (let i = 0; i < l; i++) {\n        const s = strings[i];\n        // The index of the end of the last attribute name. When this is\n        // positive at end of a string, it means we're in an attribute value\n        // position and need to rewrite the attribute name.\n        // We also use a special value of -2 to indicate that we encountered\n        // the end of a string in attribute name position.\n        let attrNameEndIndex = -1;\n        let attrName;\n        let lastIndex = 0;\n        let match;\n        // The conditions in this loop handle the current parse state, and the\n        // assignments to the `regex` variable are the state transitions.\n        while (lastIndex < s.length) {\n            // Make sure we start searching from where we previously left off\n            regex.lastIndex = lastIndex;\n            match = regex.exec(s);\n            if (match === null) {\n                break;\n            }\n            lastIndex = regex.lastIndex;\n            if (regex === textEndRegex) {\n                if (match[COMMENT_START] === '!--') {\n                    regex = commentEndRegex;\n                }\n                else if (match[COMMENT_START] !== undefined) {\n                    // We started a weird comment, like </{\n                    regex = comment2EndRegex;\n                }\n                else if (match[TAG_NAME] !== undefined) {\n                    if (rawTextElement.test(match[TAG_NAME])) {\n                        // Record if we encounter a raw-text element. We'll switch to\n                        // this regex at the end of the tag.\n                        rawTextEndRegex = new RegExp(`</${match[TAG_NAME]}`, 'g');\n                    }\n                    regex = tagEndRegex;\n                }\n                else if (match[DYNAMIC_TAG_NAME] !== undefined) {\n                    // dynamic tag name\n                    regex = tagEndRegex;\n                }\n            }\n            else if (regex === tagEndRegex) {\n                if (match[ENTIRE_MATCH] === '>') {\n                    // End of a tag. If we had started a raw-text element, use that\n                    // regex\n                    regex = rawTextEndRegex !== null && rawTextEndRegex !== void 0 ? rawTextEndRegex : textEndRegex;\n                    // We may be ending an unquoted attribute value, so make sure we\n                    // clear any pending attrNameEndIndex\n                    attrNameEndIndex = -1;\n                }\n                else if (match[ATTRIBUTE_NAME] === undefined) {\n                    // Attribute name position\n                    attrNameEndIndex = -2;\n                }\n                else {\n                    attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS].length;\n                    attrName = match[ATTRIBUTE_NAME];\n                    regex =\n                        match[QUOTE_CHAR] === undefined\n                            ? tagEndRegex\n                            : match[QUOTE_CHAR] === '\"'\n                                ? doubleQuoteAttrEndRegex\n                                : singleQuoteAttrEndRegex;\n                }\n            }\n            else if (regex === doubleQuoteAttrEndRegex ||\n                regex === singleQuoteAttrEndRegex) {\n                regex = tagEndRegex;\n            }\n            else if (regex === commentEndRegex || regex === comment2EndRegex) {\n                regex = textEndRegex;\n            }\n            else {\n                // Not one of the five state regexes, so it must be the dynamically\n                // created raw text regex and we're at the close of that element.\n                regex = tagEndRegex;\n                rawTextEndRegex = undefined;\n            }\n        }\n        if (DEV_MODE) {\n            // If we have a attrNameEndIndex, which indicates that we should\n            // rewrite the attribute name, assert that we're in a valid attribute\n            // position - either in a tag, or a quoted attribute value.\n            console.assert(attrNameEndIndex === -1 ||\n                regex === tagEndRegex ||\n                regex === singleQuoteAttrEndRegex ||\n                regex === doubleQuoteAttrEndRegex, 'unexpected parse state B');\n        }\n        // We have four cases:\n        //  1. We're in text position, and not in a raw text element\n        //     (regex === textEndRegex): insert a comment marker.\n        //  2. We have a non-negative attrNameEndIndex which means we need to\n        //     rewrite the attribute name to add a bound attribute suffix.\n        //  3. We're at the non-first binding in a multi-binding attribute, use a\n        //     plain marker.\n        //  4. We're somewhere else inside the tag. If we're in attribute name\n        //     position (attrNameEndIndex === -2), add a sequential suffix to\n        //     generate a unique attribute name.\n        // Detect a binding next to self-closing tag end and insert a space to\n        // separate the marker from the tag end:\n        const end = regex === tagEndRegex && strings[i + 1].startsWith('/>') ? ' ' : '';\n        html +=\n            regex === textEndRegex\n                ? s + nodeMarker\n                : attrNameEndIndex >= 0\n                    ? (attrNames.push(attrName),\n                        s.slice(0, attrNameEndIndex) +\n                            boundAttributeSuffix +\n                            s.slice(attrNameEndIndex)) +\n                        marker +\n                        end\n                    : s +\n                        marker +\n                        (attrNameEndIndex === -2 ? (attrNames.push(undefined), i) : end);\n    }\n    const htmlResult = html + (strings[l] || '<?>') + (type === SVG_RESULT ? '</svg>' : '');\n    // Returned as an array for terseness\n    return [\n        policy !== undefined\n            ? policy.createHTML(htmlResult)\n            : htmlResult,\n        attrNames,\n    ];\n};\nclass Template {\n    constructor({ strings, _$litType$: type }, options) {\n        /** @internal */\n        this.parts = [];\n        let node;\n        let nodeIndex = 0;\n        let attrNameIndex = 0;\n        const partCount = strings.length - 1;\n        const parts = this.parts;\n        // Create template element\n        const [html, attrNames] = getTemplateHtml(strings, type);\n        this.el = Template.createElement(html, options);\n        walker.currentNode = this.el.content;\n        // Reparent SVG nodes into template root\n        if (type === SVG_RESULT) {\n            const content = this.el.content;\n            const svgElement = content.firstChild;\n            svgElement.remove();\n            content.append(...svgElement.childNodes);\n        }\n        // Walk the template to find binding markers and create TemplateParts\n        while ((node = walker.nextNode()) !== null && parts.length < partCount) {\n            if (node.nodeType === 1) {\n                // TODO (justinfagnani): for attempted dynamic tag names, we don't\n                // increment the bindingIndex, and it'll be off by 1 in the element\n                // and off by two after it.\n                if (node.hasAttributes()) {\n                    // We defer removing bound attributes because on IE we might not be\n                    // iterating attributes in their template order, and would sometimes\n                    // remove an attribute that we still need to create a part for.\n                    const attrsToRemove = [];\n                    for (const name of node.getAttributeNames()) {\n                        // `name` is the name of the attribute we're iterating over, but not\n                        // _neccessarily_ the name of the attribute we will create a part\n                        // for. They can be different in browsers that don't iterate on\n                        // attributes in source order. In that case the attrNames array\n                        // contains the attribute name we'll process next. We only need the\n                        // attribute name here to know if we should process a bound attribute\n                        // on this element.\n                        if (name.endsWith(boundAttributeSuffix) ||\n                            name.startsWith(marker)) {\n                            const realName = attrNames[attrNameIndex++];\n                            attrsToRemove.push(name);\n                            if (realName !== undefined) {\n                                // Lowercase for case-sensitive SVG attributes like viewBox\n                                const value = node.getAttribute(realName.toLowerCase() + boundAttributeSuffix);\n                                const statics = value.split(marker);\n                                const m = /([.?@])?(.*)/.exec(realName);\n                                parts.push({\n                                    type: ATTRIBUTE_PART,\n                                    index: nodeIndex,\n                                    name: m[2],\n                                    strings: statics,\n                                    ctor: m[1] === '.'\n                                        ? PropertyPart\n                                        : m[1] === '?'\n                                            ? BooleanAttributePart\n                                            : m[1] === '@'\n                                                ? EventPart\n                                                : AttributePart,\n                                });\n                            }\n                            else {\n                                parts.push({\n                                    type: ELEMENT_PART,\n                                    index: nodeIndex,\n                                });\n                            }\n                        }\n                    }\n                    for (const name of attrsToRemove) {\n                        node.removeAttribute(name);\n                    }\n                }\n                // TODO (justinfagnani): benchmark the regex against testing for each\n                // of the 3 raw text element names.\n                if (rawTextElement.test(node.tagName)) {\n                    // For raw text elements we need to split the text content on\n                    // markers, create a Text node for each segment, and create\n                    // a TemplatePart for each marker.\n                    const strings = node.textContent.split(marker);\n                    const lastIndex = strings.length - 1;\n                    if (lastIndex > 0) {\n                        node.textContent = trustedTypes\n                            ? trustedTypes.emptyScript\n                            : '';\n                        // Generate a new text node for each literal section\n                        // These nodes are also used as the markers for node parts\n                        // We can't use empty text nodes as markers because they're\n                        // normalized in some browsers (TODO: check)\n                        for (let i = 0; i < lastIndex; i++) {\n                            node.append(strings[i], createMarker());\n                            // Walk past the marker node we just added\n                            walker.nextNode();\n                            parts.push({ type: CHILD_PART, index: ++nodeIndex });\n                        }\n                        // Note because this marker is added after the walker's current\n                        // node, it will be walked to in the outer loop (and ignored), so\n                        // we don't need to adjust nodeIndex here\n                        node.append(strings[lastIndex], createMarker());\n                    }\n                }\n            }\n            else if (node.nodeType === 8) {\n                const data = node.data;\n                if (data === markerMatch) {\n                    parts.push({ type: CHILD_PART, index: nodeIndex });\n                }\n                else {\n                    let i = -1;\n                    while ((i = node.data.indexOf(marker, i + 1)) !== -1) {\n                        // Comment node has a binding marker inside, make an inactive part\n                        // The binding won't work, but subsequent bindings will\n                        // TODO (justinfagnani): consider whether it's even worth it to\n                        // make bindings in comments work\n                        parts.push({ type: COMMENT_PART, index: nodeIndex });\n                        // Move to the end of the match\n                        i += marker.length - 1;\n                    }\n                }\n            }\n            nodeIndex++;\n        }\n    }\n    // Overridden via `litHtmlPlatformSupport` to provide platform support.\n    static createElement(html, _options) {\n        const el = d.createElement('template');\n        el.innerHTML = html;\n        return el;\n    }\n}\nfunction resolveDirective(part, value, parent = part, attributeIndex) {\n    var _a, _b, _c;\n    var _d;\n    // Bail early if the value is explicitly noChange. Note, this means any\n    // nested directive is still attached and is not run.\n    if (value === noChange) {\n        return value;\n    }\n    let currentDirective = attributeIndex !== undefined\n        ? (_a = parent.__directives) === null || _a === void 0 ? void 0 : _a[attributeIndex] : parent.__directive;\n    const nextDirectiveConstructor = isPrimitive(value)\n        ? undefined\n        : value._$litDirective$;\n    if ((currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective.constructor) !== nextDirectiveConstructor) {\n        (_b = currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective._$setDirectiveConnected) === null || _b === void 0 ? void 0 : _b.call(currentDirective, false);\n        if (nextDirectiveConstructor === undefined) {\n            currentDirective = undefined;\n        }\n        else {\n            currentDirective = new nextDirectiveConstructor(part);\n            currentDirective._$initialize(part, parent, attributeIndex);\n        }\n        if (attributeIndex !== undefined) {\n            ((_c = (_d = parent).__directives) !== null && _c !== void 0 ? _c : (_d.__directives = []))[attributeIndex] = currentDirective;\n        }\n        else {\n            parent.__directive = currentDirective;\n        }\n    }\n    if (currentDirective !== undefined) {\n        value = resolveDirective(part, currentDirective._$resolve(part, value.values), currentDirective, attributeIndex);\n    }\n    return value;\n}\n/**\n * An updateable instance of a Template. Holds references to the Parts used to\n * update the template instance.\n */\nclass TemplateInstance {\n    constructor(template, parent) {\n        /** @internal */\n        this._parts = [];\n        /** @internal */\n        this._$disconnectableChildren = undefined;\n        this._$template = template;\n        this._$parent = parent;\n    }\n    // This method is separate from the constructor because we need to return a\n    // DocumentFragment and we don't want to hold onto it with an instance field.\n    _clone(options) {\n        var _a;\n        const { el: { content }, parts: parts, } = this._$template;\n        const fragment = ((_a = options === null || options === void 0 ? void 0 : options.creationScope) !== null && _a !== void 0 ? _a : d).importNode(content, true);\n        walker.currentNode = fragment;\n        let node = walker.nextNode();\n        let nodeIndex = 0;\n        let partIndex = 0;\n        let templatePart = parts[0];\n        while (templatePart !== undefined) {\n            if (nodeIndex === templatePart.index) {\n                let part;\n                if (templatePart.type === CHILD_PART) {\n                    part = new ChildPart(node, node.nextSibling, this, options);\n                }\n                else if (templatePart.type === ATTRIBUTE_PART) {\n                    part = new templatePart.ctor(node, templatePart.name, templatePart.strings, this, options);\n                }\n                else if (templatePart.type === ELEMENT_PART) {\n                    part = new ElementPart(node, this, options);\n                }\n                this._parts.push(part);\n                templatePart = parts[++partIndex];\n            }\n            if (nodeIndex !== (templatePart === null || templatePart === void 0 ? void 0 : templatePart.index)) {\n                node = walker.nextNode();\n                nodeIndex++;\n            }\n        }\n        return fragment;\n    }\n    _update(values) {\n        let i = 0;\n        for (const part of this._parts) {\n            if (part !== undefined) {\n                if (part.strings !== undefined) {\n                    part._$setValue(values, part, i);\n                    // The number of values the part consumes is part.strings.length - 1\n                    // since values are in between template spans. We increment i by 1\n                    // later in the loop, so increment it by part.strings.length - 2 here\n                    i += part.strings.length - 2;\n                }\n                else {\n                    part._$setValue(values[i]);\n                }\n            }\n            i++;\n        }\n    }\n}\nclass ChildPart {\n    constructor(startNode, endNode, parent, options) {\n        this.type = CHILD_PART;\n        // The following fields will be patched onto ChildParts when required by\n        // AsyncDirective\n        /** @internal */\n        this._$disconnectableChildren = undefined;\n        this._$startNode = startNode;\n        this._$endNode = endNode;\n        this._$parent = parent;\n        this.options = options;\n        if (ENABLE_EXTRA_SECURITY_HOOKS) {\n            // Explicitly initialize for consistent class shape.\n            this._textSanitizer = undefined;\n        }\n    }\n    /**\n     * Sets the connection state for any `AsyncDirectives` contained\n     * within this part and runs their `disconnected` or `reconnected`, according\n     * to the `isConnected` argument.\n     */\n    setConnected(isConnected) {\n        var _a;\n        (_a = this._$setChildPartConnected) === null || _a === void 0 ? void 0 : _a.call(this, isConnected);\n    }\n    /**\n     * The parent node into which the part renders its content.\n     *\n     * A ChildPart's content consists of a range of adjacent child nodes of\n     * `.parentNode`, possibly bordered by 'marker nodes' (`.startNode` and\n     * `.endNode`).\n     *\n     * - If both `.startNode` and `.endNode` are non-null, then the part's content\n     * consists of all siblings between `.startNode` and `.endNode`, exclusively.\n     *\n     * - If `.startNode` is non-null but `.endNode` is null, then the part's\n     * content consists of all siblings following `.startNode`, up to and\n     * including the last child of `.parentNode`. If `.endNode` is non-null, then\n     * `.startNode` will always be non-null.\n     *\n     * - If both `.endNode` and `.startNode` are null, then the part's content\n     * consists of all child nodes of `.parentNode`.\n     */\n    get parentNode() {\n        return wrap(this._$startNode).parentNode;\n    }\n    /**\n     * The part's leading marker node, if any. See `.parentNode` for more\n     * information.\n     */\n    get startNode() {\n        return this._$startNode;\n    }\n    /**\n     * The part's trailing marker node, if any. See `.parentNode` for more\n     * information.\n     */\n    get endNode() {\n        return this._$endNode;\n    }\n    _$setValue(value, directiveParent = this) {\n        value = resolveDirective(this, value, directiveParent);\n        if (isPrimitive(value)) {\n            // Non-rendering child values. It's important that these do not render\n            // empty text nodes to avoid issues with preventing default <slot>\n            // fallback content.\n            if (value === nothing || value == null || value === '') {\n                if (this._$committedValue !== nothing) {\n                    this._$clear();\n                }\n                this._$committedValue = nothing;\n            }\n            else if (value !== this._$committedValue && value !== noChange) {\n                this._commitText(value);\n            }\n        }\n        else if (value._$litType$ !== undefined) {\n            this._commitTemplateResult(value);\n        }\n        else if (value.nodeType !== undefined) {\n            this._commitNode(value);\n        }\n        else if (isIterable(value)) {\n            this._commitIterable(value);\n        }\n        else {\n            // Fallback, will render the string representation\n            this._commitText(value);\n        }\n    }\n    _insert(node, ref = this._$endNode) {\n        return wrap(wrap(this._$startNode).parentNode).insertBefore(node, ref);\n    }\n    _commitNode(value) {\n        var _a;\n        if (this._$committedValue !== value) {\n            this._$clear();\n            if (ENABLE_EXTRA_SECURITY_HOOKS &&\n                sanitizerFactoryInternal !== noopSanitizer) {\n                const parentNodeName = (_a = this._$startNode.parentNode) === null || _a === void 0 ? void 0 : _a.nodeName;\n                if (parentNodeName === 'STYLE' || parentNodeName === 'SCRIPT') {\n                    this._insert(new Text('/* lit-html will not write ' +\n                        'TemplateResults to scripts and styles */'));\n                    return;\n                }\n            }\n            this._$committedValue = this._insert(value);\n        }\n    }\n    _commitText(value) {\n        const node = wrap(this._$startNode).nextSibling;\n        // TODO(justinfagnani): Can we just check if this._$committedValue is primitive?\n        if (node !== null &&\n            node.nodeType === 3 /* Node.TEXT_NODE */ &&\n            (this._$endNode === null\n                ? wrap(node).nextSibling === null\n                : node === wrap(this._$endNode).previousSibling)) {\n            if (ENABLE_EXTRA_SECURITY_HOOKS) {\n                if (this._textSanitizer === undefined) {\n                    this._textSanitizer = createSanitizer(node, 'data', 'property');\n                }\n                value = this._textSanitizer(value);\n            }\n            // If we only have a single text node between the markers, we can just\n            // set its value, rather than replacing it.\n            node.data = value;\n        }\n        else {\n            if (ENABLE_EXTRA_SECURITY_HOOKS) {\n                const textNode = document.createTextNode('');\n                this._commitNode(textNode);\n                // When setting text content, for security purposes it matters a lot\n                // what the parent is. For example, <style> and <script> need to be\n                // handled with care, while <span> does not. So first we need to put a\n                // text node into the document, then we can sanitize its contentx.\n                if (this._textSanitizer === undefined) {\n                    this._textSanitizer = createSanitizer(textNode, 'data', 'property');\n                }\n                value = this._textSanitizer(value);\n                textNode.data = value;\n            }\n            else {\n                this._commitNode(d.createTextNode(value));\n            }\n        }\n        this._$committedValue = value;\n    }\n    _commitTemplateResult(result) {\n        var _a;\n        const { values, _$litType$ } = result;\n        // If $litType$ is a number, result is a plain TemplateResult and we get\n        // the template from the template cache. If not, result is a\n        // CompiledTemplateResult and _$litType$ is a CompiledTemplate and we need\n        // to create the <template> element the first time we see it.\n        const template = typeof _$litType$ === 'number'\n            ? this._$getTemplate(result)\n            : (_$litType$.el === undefined &&\n                (_$litType$.el = Template.createElement(_$litType$.h, this.options)),\n                _$litType$);\n        if (((_a = this._$committedValue) === null || _a === void 0 ? void 0 : _a._$template) === template) {\n            this._$committedValue._update(values);\n        }\n        else {\n            const instance = new TemplateInstance(template, this);\n            const fragment = instance._clone(this.options);\n            instance._update(values);\n            this._commitNode(fragment);\n            this._$committedValue = instance;\n        }\n    }\n    // Overridden via `litHtmlPlatformSupport` to provide platform support.\n    /** @internal */\n    _$getTemplate(result) {\n        let template = templateCache.get(result.strings);\n        if (template === undefined) {\n            templateCache.set(result.strings, (template = new Template(result)));\n        }\n        return template;\n    }\n    _commitIterable(value) {\n        // For an Iterable, we create a new InstancePart per item, then set its\n        // value to the item. This is a little bit of overhead for every item in\n        // an Iterable, but it lets us recurse easily and efficiently update Arrays\n        // of TemplateResults that will be commonly returned from expressions like:\n        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n        // If value is an array, then the previous render was of an\n        // iterable and value will contain the ChildParts from the previous\n        // render. If value is not an array, clear this part and make a new\n        // array for ChildParts.\n        if (!isArray(this._$committedValue)) {\n            this._$committedValue = [];\n            this._$clear();\n        }\n        // Lets us keep track of how many items we stamped so we can clear leftover\n        // items from a previous render\n        const itemParts = this._$committedValue;\n        let partIndex = 0;\n        let itemPart;\n        for (const item of value) {\n            if (partIndex === itemParts.length) {\n                // If no existing part, create a new one\n                // TODO (justinfagnani): test perf impact of always creating two parts\n                // instead of sharing parts between nodes\n                // https://github.com/lit/lit/issues/1266\n                itemParts.push((itemPart = new ChildPart(this._insert(createMarker()), this._insert(createMarker()), this, this.options)));\n            }\n            else {\n                // Reuse an existing part\n                itemPart = itemParts[partIndex];\n            }\n            itemPart._$setValue(item);\n            partIndex++;\n        }\n        if (partIndex < itemParts.length) {\n            // itemParts always have end nodes\n            this._$clear(itemPart && wrap(itemPart._$endNode).nextSibling, partIndex);\n            // Truncate the parts array so _value reflects the current state\n            itemParts.length = partIndex;\n        }\n    }\n    /**\n     * Removes the nodes contained within this Part from the DOM.\n     *\n     * @param start Start node to clear from, for clearing a subset of the part's\n     *     DOM (used when truncating iterables)\n     * @param from  When `start` is specified, the index within the iterable from\n     *     which ChildParts are being removed, used for disconnecting directives in\n     *     those Parts.\n     *\n     * @internal\n     */\n    _$clear(start = wrap(this._$startNode).nextSibling, from) {\n        var _a;\n        (_a = this._$setChildPartConnected) === null || _a === void 0 ? void 0 : _a.call(this, false, true, from);\n        while (start && start !== this._$endNode) {\n            const n = wrap(start).nextSibling;\n            wrap(start).remove();\n            start = n;\n        }\n    }\n}\nclass AttributePart {\n    constructor(element, name, strings, parent, options) {\n        this.type = ATTRIBUTE_PART;\n        /** @internal */\n        this._$committedValue = nothing;\n        /** @internal */\n        this._$disconnectableChildren = undefined;\n        /** @internal */\n        this._setDirectiveConnected = undefined;\n        this.element = element;\n        this.name = name;\n        this._$parent = parent;\n        this.options = options;\n        if (strings.length > 2 || strings[0] !== '' || strings[1] !== '') {\n            this._$committedValue = new Array(strings.length - 1).fill(nothing);\n            this.strings = strings;\n        }\n        else {\n            this._$committedValue = nothing;\n        }\n        if (ENABLE_EXTRA_SECURITY_HOOKS) {\n            this._sanitizer = undefined;\n        }\n    }\n    get tagName() {\n        return this.element.tagName;\n    }\n    /**\n     * Sets the value of this part by resolving the value from possibly multiple\n     * values and static strings and committing it to the DOM.\n     * If this part is single-valued, `this._strings` will be undefined, and the\n     * method will be called with a single value argument. If this part is\n     * multi-value, `this._strings` will be defined, and the method is called\n     * with the value array of the part's owning TemplateInstance, and an offset\n     * into the value array from which the values should be read.\n     * This method is overloaded this way to eliminate short-lived array slices\n     * of the template instance values, and allow a fast-path for single-valued\n     * parts.\n     *\n     * @param value The part value, or an array of values for multi-valued parts\n     * @param valueIndex the index to start reading values from. `undefined` for\n     *   single-valued parts\n     * @param noCommit causes the part to not commit its value to the DOM. Used\n     *   in hydration to prime attribute parts with their first-rendered value,\n     *   but not set the attribute, and in SSR to no-op the DOM operation and\n     *   capture the value for serialization.\n     *\n     * @internal\n     */\n    _$setValue(value, directiveParent = this, valueIndex, noCommit) {\n        const strings = this.strings;\n        // Whether any of the values has changed, for dirty-checking\n        let change = false;\n        if (strings === undefined) {\n            // Single-value binding case\n            value = resolveDirective(this, value, directiveParent, 0);\n            change =\n                !isPrimitive(value) ||\n                    (value !== this._$committedValue && value !== noChange);\n            if (change) {\n                this._$committedValue = value;\n            }\n        }\n        else {\n            // Interpolation case\n            const values = value;\n            value = strings[0];\n            let i, v;\n            for (i = 0; i < strings.length - 1; i++) {\n                v = resolveDirective(this, values[valueIndex + i], directiveParent, i);\n                if (v === noChange) {\n                    // If the user-provided value is `noChange`, use the previous value\n                    v = this._$committedValue[i];\n                }\n                change || (change = !isPrimitive(v) || v !== this._$committedValue[i]);\n                if (v === nothing) {\n                    value = nothing;\n                }\n                else if (value !== nothing) {\n                    value += (v !== null && v !== void 0 ? v : '') + strings[i + 1];\n                }\n                // We always record each value, even if one is `nothing`, for future\n                // change detection.\n                this._$committedValue[i] = v;\n            }\n        }\n        if (change && !noCommit) {\n            this._commitValue(value);\n        }\n    }\n    /** @internal */\n    _commitValue(value) {\n        if (value === nothing) {\n            wrap(this.element).removeAttribute(this.name);\n        }\n        else {\n            if (ENABLE_EXTRA_SECURITY_HOOKS) {\n                if (this._sanitizer === undefined) {\n                    this._sanitizer = sanitizerFactoryInternal(this.element, this.name, 'attribute');\n                }\n                value = this._sanitizer(value !== null && value !== void 0 ? value : '');\n            }\n            wrap(this.element).setAttribute(this.name, (value !== null && value !== void 0 ? value : ''));\n        }\n    }\n}\nclass PropertyPart extends AttributePart {\n    constructor() {\n        super(...arguments);\n        this.type = PROPERTY_PART;\n    }\n    /** @internal */\n    _commitValue(value) {\n        if (ENABLE_EXTRA_SECURITY_HOOKS) {\n            if (this._sanitizer === undefined) {\n                this._sanitizer = sanitizerFactoryInternal(this.element, this.name, 'property');\n            }\n            value = this._sanitizer(value);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.element[this.name] = value === nothing ? undefined : value;\n    }\n}\nclass BooleanAttributePart extends AttributePart {\n    constructor() {\n        super(...arguments);\n        this.type = BOOLEAN_ATTRIBUTE_PART;\n    }\n    /** @internal */\n    _commitValue(value) {\n        if (value && value !== nothing) {\n            wrap(this.element).setAttribute(this.name, '');\n        }\n        else {\n            wrap(this.element).removeAttribute(this.name);\n        }\n    }\n}\nclass EventPart extends AttributePart {\n    constructor() {\n        super(...arguments);\n        this.type = EVENT_PART;\n    }\n    // EventPart does not use the base _$setValue/_resolveValue implementation\n    // since the dirty checking is more complex\n    /** @internal */\n    _$setValue(newListener, directiveParent = this) {\n        var _a;\n        newListener = (_a = resolveDirective(this, newListener, directiveParent, 0)) !== null && _a !== void 0 ? _a : nothing;\n        if (newListener === noChange) {\n            return;\n        }\n        const oldListener = this._$committedValue;\n        // If the new value is nothing or any options change we have to remove the\n        // part as a listener.\n        const shouldRemoveListener = (newListener === nothing && oldListener !== nothing) ||\n            newListener.capture !==\n                oldListener.capture ||\n            newListener.once !==\n                oldListener.once ||\n            newListener.passive !==\n                oldListener.passive;\n        // If the new value is not nothing and we removed the listener, we have\n        // to add the part as a listener.\n        const shouldAddListener = newListener !== nothing &&\n            (oldListener === nothing || shouldRemoveListener);\n        if (shouldRemoveListener) {\n            this.element.removeEventListener(this.name, this, oldListener);\n        }\n        if (shouldAddListener) {\n            // Beware: IE11 and Chrome 41 don't like using the listener as the\n            // options object. Figure out how to deal w/ this in IE11 - maybe\n            // patch addEventListener?\n            this.element.addEventListener(this.name, this, newListener);\n        }\n        this._$committedValue = newListener;\n    }\n    handleEvent(event) {\n        var _a, _b;\n        if (typeof this._$committedValue === 'function') {\n            // TODO (justinfagnani): do we need to default to this.element?\n            // It'll always be the same as `e.currentTarget`.\n            this._$committedValue.call((_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : this.element, event);\n        }\n        else {\n            this._$committedValue.handleEvent(event);\n        }\n    }\n}\nclass ElementPart {\n    constructor(element, parent, options) {\n        this.element = element;\n        this.type = ELEMENT_PART;\n        /** @internal */\n        this._$disconnectableChildren = undefined;\n        /** @internal */\n        this._setDirectiveConnected = undefined;\n        this._$parent = parent;\n        this.options = options;\n    }\n    _$setValue(value) {\n        resolveDirective(this, value);\n    }\n}\n/**\n * END USERS SHOULD NOT RELY ON THIS OBJECT.\n *\n * Private exports for use by other Lit packages, not intended for use by\n * external users.\n *\n * We currently do not make a mangled rollup build of the lit-ssr code. In order\n * to keep a number of (otherwise private) top-level exports  mangled in the\n * client side code, we export a _\u03A3 object containing those members (or\n * helper methods for accessing private fields of those members), and then\n * re-export them for use in lit-ssr. This keeps lit-ssr agnostic to whether the\n * client-side code is being used in `dev` mode or `prod` mode.\n *\n * This has a unique name, to disambiguate it from private exports in\n * lit-element, which re-exports all of lit-html.\n *\n * @private\n */\nexport const _\u03A3 = {\n    // Used in lit-ssr\n    _boundAttributeSuffix: boundAttributeSuffix,\n    _marker: marker,\n    _markerMatch: markerMatch,\n    _HTML_RESULT: HTML_RESULT,\n    _getTemplateHtml: getTemplateHtml,\n    // Used in hydrate\n    _TemplateInstance: TemplateInstance,\n    _isIterable: isIterable,\n    _resolveDirective: resolveDirective,\n    // Used in tests and private-ssr-support\n    _ChildPart: ChildPart,\n    _AttributePart: AttributePart,\n    _BooleanAttributePart: BooleanAttributePart,\n    _EventPart: EventPart,\n    _PropertyPart: PropertyPart,\n    _ElementPart: ElementPart,\n};\n// Apply polyfills if available\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(_d = (_c = globalThis)['litHtmlPlatformSupport']) === null || _d === void 0 ? void 0 : _d.call(_c, Template, ChildPart);\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for lit-html usage.\n// TODO(justinfagnani): inject version number at build time\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n((_e = (_f = globalThis)['litHtmlVersions']) !== null && _e !== void 0 ? _e : (_f['litHtmlVersions'] = [])).push('2.0.0-rc.3');\n//# sourceMappingURL=lit-html.js.map", "/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nvar _a, _b, _c, _d, _e;\nvar _f;\n/**\n * The main LitElement module, which defines the [[`LitElement`]] base class and\n * related APIs.\n *\n *  LitElement components can define a template and a set of observed\n * properties. Changing an observed property triggers a re-render of the\n * element.\n *\n *  Import [[`LitElement`]] and [[`html`]] from this module to create a\n * component:\n *\n *  ```js\n * import {LitElement, html} from 'lit-element';\n *\n * class MyElement extends LitElement {\n *\n *   // Declare observed properties\n *   static get properties() {\n *     return {\n *       adjective: {}\n *     }\n *   }\n *\n *   constructor() {\n *     this.adjective = 'awesome';\n *   }\n *\n *   // Define the element's template\n *   render() {\n *     return html`<p>your ${adjective} template here</p>`;\n *   }\n * }\n *\n * customElements.define('my-element', MyElement);\n * ```\n *\n * `LitElement` extends [[`ReactiveElement`]] and adds lit-html templating.\n * The `ReactiveElement` class is provided for users that want to build\n * their own custom element base classes that don't use lit-html.\n *\n * @packageDocumentation\n */\nimport { ReactiveElement } from '@lit/reactive-element';\nimport { render, noChange } from 'lit-html';\nexport * from '@lit/reactive-element';\nexport * from 'lit-html';\n// For backwards compatibility export ReactiveElement as UpdatingElement. Note,\n// IE transpilation requires exporting like this.\nexport const UpdatingElement = ReactiveElement;\nconst DEV_MODE = true;\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for LitElement usage.\n// TODO(justinfagnani): inject version number at build time\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n((_a = (_f = globalThis)['litElementVersions']) !== null && _a !== void 0 ? _a : (_f['litElementVersions'] = [])).push('3.0.0-rc.2');\n/**\n * Base element class that manages element properties and attributes, and\n * renders a lit-html template.\n *\n * To define a component, subclass `LitElement` and implement a\n * `render` method to provide the component's template. Define properties\n * using the [[`properties`]] property or the [[`property`]] decorator.\n */\nexport class LitElement extends ReactiveElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * @category rendering\n         */\n        this.renderOptions = { host: this };\n        this.__childPart = undefined;\n    }\n    /**\n     * @category rendering\n     */\n    createRenderRoot() {\n        var _a;\n        var _b;\n        const renderRoot = super.createRenderRoot();\n        // When adoptedStyleSheets are shimmed, they are inserted into the\n        // shadowRoot by createRenderRoot. Adjust the renderBefore node so that\n        // any styles in Lit content render before adoptedStyleSheets. This is\n        // important so that adoptedStyleSheets have precedence over styles in\n        // the shadowRoot.\n        (_a = (_b = this.renderOptions).renderBefore) !== null && _a !== void 0 ? _a : (_b.renderBefore = renderRoot.firstChild);\n        return renderRoot;\n    }\n    /**\n     * Updates the element. This method reflects property values to attributes\n     * and calls `render` to render DOM via lit-html. Setting properties inside\n     * this method will *not* trigger another update.\n     * @param changedProperties Map of changed properties with old values\n     * @category updates\n     */\n    update(changedProperties) {\n        // Setting properties in `render` should not trigger an update. Since\n        // updates are allowed after super.update, it's important to call `render`\n        // before that.\n        const value = this.render();\n        super.update(changedProperties);\n        this.__childPart = render(value, this.renderRoot, this.renderOptions);\n    }\n    // TODO(kschaaf): Consider debouncing directive disconnection so element moves\n    // do not thrash directive callbacks\n    // https://github.com/lit/lit/issues/1457\n    /**\n     * @category lifecycle\n     */\n    connectedCallback() {\n        var _a;\n        super.connectedCallback();\n        (_a = this.__childPart) === null || _a === void 0 ? void 0 : _a.setConnected(true);\n    }\n    /**\n     * @category lifecycle\n     */\n    disconnectedCallback() {\n        var _a;\n        super.disconnectedCallback();\n        (_a = this.__childPart) === null || _a === void 0 ? void 0 : _a.setConnected(false);\n    }\n    /**\n     * Invoked on each update to perform rendering tasks. This method may return\n     * any value renderable by lit-html's `ChildPart` - typically a\n     * `TemplateResult`. Setting properties inside this method will *not* trigger\n     * the element to update.\n     * @category rendering\n     */\n    render() {\n        return noChange;\n    }\n}\n/**\n * Ensure this class is marked as `finalized` as an optimization ensuring\n * it will not needlessly try to `finalize`.\n *\n * Note this property name is a string to prevent breaking Closure JS Compiler\n * optimizations. See @lit/reactive-element for more information.\n */\nLitElement['finalized'] = true;\nLitElement._$litElement$ = true;\n// Install hydration if available\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(_c = (_b = globalThis)['litElementHydrateSupport']) === null || _c === void 0 ? void 0 : _c.call(_b, { LitElement });\n// Apply polyfills if available\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n(_e = (_d = globalThis)['litElementPlatformSupport']) === null || _e === void 0 ? void 0 : _e.call(_d, { LitElement });\n// DEV mode warnings\nif (DEV_MODE) {\n    // Note, for compatibility with closure compilation, this access\n    // needs to be as a string property index.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    LitElement['finalize'] = function () {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const finalized = ReactiveElement.finalize.call(this);\n        if (!finalized) {\n            return false;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const warnRemoved = (obj, name) => {\n            if (obj[name] !== undefined) {\n                console.warn(`\\`${name}\\` is implemented. It ` +\n                    `has been removed from this version of LitElement. `\n                // TODO(sorvell): add link to changelog when location has stabilized.\n                // + See the changelog at https://github.com/lit/lit/blob/main/packages/lit-element/CHANGELOG.md`\n                );\n            }\n        };\n        [`render`, `getStyles`].forEach((name) => \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        warnRemoved(this, name));\n        [`adoptStyles`].forEach((name) => \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        warnRemoved(this.prototype, name));\n        return true;\n    };\n}\n/**\n * END USERS SHOULD NOT RELY ON THIS OBJECT.\n *\n * Private exports for use by other Lit packages, not intended for use by\n * external users.\n *\n * We currently do not make a mangled rollup build of the lit-ssr code. In order\n * to keep a number of (otherwise private) top-level exports  mangled in the\n * client side code, we export a _\u03A6 object containing those members (or\n * helper methods for accessing private fields of those members), and then\n * re-export them for use in lit-ssr. This keeps lit-ssr agnostic to whether the\n * client-side code is being used in `dev` mode or `prod` mode.\n *\n * This has a unique name, to disambiguate it from private exports in\n * lit-html, since this module re-exports all of lit-html.\n *\n * @private\n */\nexport const _\u03A6 = {\n    _$attributeToProperty: (el, name, value) => {\n        // eslint-disable-next-line\n        el._$attributeToProperty(name, value);\n    },\n    // eslint-disable-next-line\n    _$changedProperties: (el) => el._$changedProperties,\n};\n//# sourceMappingURL=lit-element.js.map"],
  "mappings": "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",
  "names": []
}
